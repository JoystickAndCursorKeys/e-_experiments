; Source: /home/flamsidoo/Documents/deb/example-game/python/python.e-
; Generated by: e- Compiler 0.7a (Linux 64-bit) - Copyright (C) 2020-2022 0xC0DE
; On: Thu 2022-02-24 07:34:38


macro stal __stal_addr
  equb &9d, lo(__stal_addr), hi(__stal_addr) ; sta abs,x
endmacro

macro ldal __ldal_addr
  equb &bd, lo(__ldal_addr), hi(__ldal_addr) ; lda abs,x
endmacro

macro incl __incl_addr
  equb &fe, lo(__incl_addr), hi(__incl_addr) ; inc abs,x
endmacro

macro decl __decl_addr
  equb &de, lo(__decl_addr), hi(__decl_addr) ; dec abs,x
endmacro

macro adcl __adcl_addr
  equb &7d, lo(__adcl_addr), hi(__adcl_addr) ; adc abs,x
endmacro

macro sbcl __sbcl_addr
  equb &fd, lo(__sbcl_addr), hi(__sbcl_addr) ; sbc abs,x
endmacro

macro andl __andl_addr
  equb &3d, lo(__andl_addr), hi(__andl_addr) ; and abs,x
endmacro

macro eorl __eorl_addr
  equb &5d, lo(__eorl_addr), hi(__eorl_addr) ; eor abs,x
endmacro

macro ldyl __ldyl_addr
  equb &bc, lo(__ldyl_addr), hi(__ldyl_addr) ; ldy abs,x
endmacro

macro oral __oral_addr
  equb &1d, lo(__oral_addr), hi(__oral_addr) ; ora abs,x
endmacro

macro cmpl __cmpl_addr
  equb &dd, lo(__cmpl_addr), hi(__cmpl_addr) ; cmp abs,x
endmacro

  org &0e00
.___program_start___
  jmp _main
  equs "Generated by e- Compiler | 0.7a | Linux 64-bit | Copyright (C) 2020-2022 0xC0DE"
{
  __P__=*
  org &00
.*___sys_vsync_hook
  equw 0
.*___sys_rtc_hook
  equw 0
.*___sys_is_electron
  equb 0
.*___sys_bbctimer
  equb 0
.*___gfx_x
  equw 0
.*___gfx_y
  equw 0
.*___spr_screen
  equw 0
.*___spr_sprite
  equw 0
.*___spr_table
  equw 0
.*___spr_xcoord
  equw 0
.*___spr_ycoord
  equb 0
.*___spr_ymod8
  equb 0
.*___spr_8minusymod8
  equb 0
.*_state
  equb 0
.*_headx
  equb 0
.*_heady
  equb 0
.*_tailx
  equb 0
.*_taily
  equb 0
.*_headcornerx
  equb 0
.*_headcornery
  equb 0
.*_headcornertype
  equb 0
.*_headcornerstate
  equb 0
.*_tailcornerx
  equb 0
.*_tailcornery
  equb 0
.*_tailcornerstate
  equb 0
.*_tailtrail
  equb 0
.*_headtrail
  equb 0
.*_grow
  equb 0
.*_moved
  equb 0
.*_tune_counter
  equb 0
.*_tune_index
  equw 0
.*_score
  equw 0
.*_time
  equb 0
.*_start_time
  equb 0
.*_time_counter
  equb 0
.*_time_needs_update
  equb 0
.*_lives
  equb 0
.*_level
  equb 0
.*_time_counter_reload
  equb 0
.*_stuck
  equb 0
.*_time_enabled
  equb 0
.*_tune_enabled
  equb 0
.*_tune_counter_reload
  equb 0
.*_tune_note_len
  equb 0
.*_n_diamonds
  equb 0
.*_music_toggle
  equb 0
.*_hiscore
  equw 0
.*_key_music_counter
  equb 0
  if (*>=&b0): error "Ran out of space in zeropage for global e- variables!": endif
  org __P__
}
.___sys_internal
{
  jmp _exit___sys_internal
   ; ##inlineasm##
    { ; ##inlineasm##
  __P__=* ; ##inlineasm##
   ; ##inlineasm##
    org &c0 ; ##inlineasm##
.*_e_t0 skip 1 ; ##inlineasm##
.*_e_t1 skip 1 ; ##inlineasm##
.*_e_t2 skip 1 ; ##inlineasm##
.*_e_t3 skip 1 ; ##inlineasm##
.*_e_t4 skip 1 ; ##inlineasm##
.*_e_t5 skip 1 ; ##inlineasm##
.*_e_t6 skip 1 ; ##inlineasm##
.*_e_t7 skip 1 ; ##inlineasm##
.*_e_t8 skip 1 ; ##inlineasm##
.*_e_t9 skip 1 ; ##inlineasm##
   ; ##inlineasm##
.*rtc_counter skip 1 ; ##inlineasm##
.*vsync_counter skip 1 ; ##inlineasm##
.*__seed skip 1 ; ##inlineasm##
   ; ##inlineasm##
    org __P__ ; ##inlineasm##
   ; ##inlineasm##
  ; see: https://llx.com/Neil/a2/mult.html ; ##inlineasm##
  ; reads 2 positive 8bit numbers directly from stack and leaves 8bit (truncated!) result in A ; ##inlineasm##
  ;&&&&TODO: check validity of this function ; ##inlineasm##
.*_e_mult8x8 ; ##inlineasm##
{ ; ##inlineasm##
    stx _e_t0 ; ##inlineasm##
    tsx ; ##inlineasm##
    lda &104,x ; operand 1 ; ##inlineasm##
    sta _e_t1 ; ##inlineasm##
    lda &103,x ; operand 2 ; ##inlineasm##
    sta _e_t2 ; ##inlineasm##
    lda #0 ; ##inlineasm##
    ldy #8 ; ##inlineasm##
.loop ; ##inlineasm##
    lsr _e_t2 ; ##inlineasm##
    bcc rot ; ##inlineasm##
    clc ; ##inlineasm##
    adc _e_t1 ; ##inlineasm##
.rot ; ##inlineasm##
    ror a ; ##inlineasm##
    ror _e_t3 ; lsb of result (A will be msb of result) ; ##inlineasm##
    dey ; ##inlineasm##
    bne loop ; ##inlineasm##
    lda _e_t3 ; return lsb, discard msb (previously in A) ; ##inlineasm##
    ldx _e_t0 ; ##inlineasm##
    rts ; ##inlineasm##
} ; ##inlineasm##
   ; ##inlineasm##
  ; see: https://llx.com/Neil/a2/mult.html ; ##inlineasm##
  ; reads 2 positive 16bit numbers directly from stack and leaves 16bit (truncated!) result in YA ; ##inlineasm##
  ;&&&&TODO: check validity of this function ; ##inlineasm##
.*_e_mult16x16 ; ##inlineasm##
{ ; ##inlineasm##
    stx _e_t0 ; ##inlineasm##
    tsx ; ##inlineasm##
    lda &106,x ; msb of operand 1 ; ##inlineasm##
    sta _e_t2 ; ##inlineasm##
    lda &105,x ; lsb of operand 1 ; ##inlineasm##
    sta _e_t1 ; ##inlineasm##
    lda &104,x ; msb of operand 2 ; ##inlineasm##
    sta _e_t4 ; ##inlineasm##
    lda &103,x ; lsb of operand 2 ; ##inlineasm##
    sta _e_t3 ; ##inlineasm##
.*_e_cont_mult16x16 ; ##inlineasm##
    lda #0 ; ##inlineasm##
    sta _e_t7 ; ##inlineasm##
    ldy #16 ; ##inlineasm##
.loop ; ##inlineasm##
    lsr _e_t4 ; ##inlineasm##
    ror _e_t3 ; ##inlineasm##
    bcc rot ; ##inlineasm##
    pha ; ##inlineasm##
    clc ; ##inlineasm##
    lda _e_t7 ; ##inlineasm##
    adc _e_t1 ; ##inlineasm##
    sta _e_t7 ; ##inlineasm##
    pla ; ##inlineasm##
    adc _e_t2 ; ##inlineasm##
.rot ; ##inlineasm##
    ror a ; ##inlineasm##
    ror _e_t7 ; ##inlineasm##
    ror _e_t6 ; ##inlineasm##
    ror _e_t5 ; ##inlineasm##
    dey ; ##inlineasm##
    bne loop ; ##inlineasm##
    ldy _e_t6 ; return lsw in YA, discard msw ; ##inlineasm##
    lda _e_t5 ; ##inlineasm##
    ldx _e_t0 ; ##inlineasm##
    rts ; ##inlineasm##
} ; ##inlineasm##
   ; ##inlineasm##
  ; Y==0 --> msb of operand 1 = 0 ; ##inlineasm##
  ; Y==1 --> msb of operand 1 is sign extension of lsb ; ##inlineasm##
  ;&&&&TODO: check validity of this function ; ##inlineasm##
.*_e_mult8x16 ; ##inlineasm##
{ ; ##inlineasm##
    stx _e_t0 ; ##inlineasm##
    tsx ; ##inlineasm##
    lda &105,x ; operand 1 (8bit) ; ##inlineasm##
    cpy #0 ; ##inlineasm##
    beq store ; ##inlineasm##
    ; do sign extend ; ##inlineasm##
    dey ; Y=0 ; ##inlineasm##
    cmp #&80 ; ##inlineasm##
    bcc store ; ##inlineasm##
    dey ; Y=&ff ; ##inlineasm##
.store ; ##inlineasm##
    sty _e_t2 ; virtual msb of operand 1 ; ##inlineasm##
    sta _e_t1 ; lsb of operand 1 ; ##inlineasm##
    lda &104,x ; msb of operand 2 ; ##inlineasm##
    sta _e_t4 ; ##inlineasm##
    lda &103,x ; lsb of operand 2 ; ##inlineasm##
    sta _e_t3 ; ##inlineasm##
    jmp _e_cont_mult16x16 ; ##inlineasm##
} ; ##inlineasm##
   ; ##inlineasm##
  ; Y==0 --> msb of operand 2 = 0 ; ##inlineasm##
  ; Y==1 --> msb of operand 2 is sign extension of lsb ; ##inlineasm##
  ;&&&&TODO: check validity of this function ; ##inlineasm##
.*_e_mult16x8 ; ##inlineasm##
{ ; ##inlineasm##
    stx _e_t0 ; ##inlineasm##
    tsx ; ##inlineasm##
    lda &103,x ; operand 2 (8bit) ; ##inlineasm##
    cpy #0 ; ##inlineasm##
    beq store ; ##inlineasm##
    ; do sign extend ; ##inlineasm##
    dey ; Y=0 ; ##inlineasm##
    cmp #&80 ; ##inlineasm##
    bcc store ; ##inlineasm##
    dey ; Y=&ff ; ##inlineasm##
.store ; ##inlineasm##
    sty _e_t4 ; virtual msb of operand 2 ; ##inlineasm##
    sta _e_t3 ; lsb of operand 2 ; ##inlineasm##
    lda &105,x ; msb of operand 1 ; ##inlineasm##
    sta _e_t2 ; ##inlineasm##
    lda &104,x ; lsb of operand 1 ; ##inlineasm##
    sta _e_t1 ; ##inlineasm##
    jmp _e_cont_mult16x16 ; ##inlineasm##
} ; ##inlineasm##
   ; ##inlineasm##
  ; A = signed 8bit number ; ##inlineasm##
.*_e_print_int8 ; ##inlineasm##
{ ; ##inlineasm##
    tay ; test 8bit number ; ##inlineasm##
    sta _e_t2 ; remember (sign of) original number ; ##inlineasm##
    bpl is_pos ; ##inlineasm##
    ; make negative number positive ; ##inlineasm##
    eor #&ff ; ##inlineasm##
    clc ; ##inlineasm##
    adc #1 ; ##inlineasm##
.is_pos ; ##inlineasm##
    sta _e_t0 ; remember number (made positive)   ; ##inlineasm##
    lda #0 ; ##inlineasm##
    pha ; marks end of string on stack ; ##inlineasm##
.div10 ; ##inlineasm##
    lda #0 ; ##inlineasm##
    sta _e_t1 ; collecting decimal digit ; ##inlineasm##
    ldy #8 ; loop counter (8 bits) ; ##inlineasm##
.loop ; ##inlineasm##
    asl _e_t0 ; ##inlineasm##
    rol _e_t1 ; ##inlineasm##
    lda _e_t1 ; ##inlineasm##
    sec: sbc #10 ; ##inlineasm##
    bcc less10 ; ##inlineasm##
    sta _e_t1 ; ##inlineasm##
    inc _e_t0 ; ##inlineasm##
.less10 ; ##inlineasm##
    dey ; ##inlineasm##
    bne loop ; ##inlineasm##
    lda _e_t1 ; ##inlineasm##
    ora #'0' ; ##inlineasm##
    pha ; ##inlineasm##
    lda _e_t0 ; ##inlineasm##
    bne div10 ; ##inlineasm##
   ; ##inlineasm##
    lda _e_t2 ; was neg? ; ##inlineasm##
    bpl is_pos2 ; ##inlineasm##
    lda #'-' ; ##inlineasm##
    jsr &ffee ; OSWRCH ; ##inlineasm##
.is_pos2 ; ##inlineasm##
    pla ; ##inlineasm##
.print ; ##inlineasm##
    jsr &ffee ; OSWRCH ; ##inlineasm##
    pla ; ##inlineasm##
    bne print ; ##inlineasm##
   ; ##inlineasm##
    rts ; ##inlineasm##
} ; ##inlineasm##
   ; ##inlineasm##
  ; A = unsigned 8bit number ; ##inlineasm##
.*_e_print_uint8 ; ##inlineasm##
{ ; ##inlineasm##
    sta _e_t0 ; remember number ; ##inlineasm##
    lda #0 ; ##inlineasm##
    pha ; marks end of string on stack ; ##inlineasm##
.div10 ; ##inlineasm##
    lda #0 ; ##inlineasm##
    sta _e_t1 ; collecting decimal digit ; ##inlineasm##
    ldy #8 ; loop counter (8 bits) ; ##inlineasm##
.loop ; ##inlineasm##
    asl _e_t0 ; ##inlineasm##
    rol _e_t1 ; ##inlineasm##
    lda _e_t1 ; ##inlineasm##
    sec: sbc #10 ; ##inlineasm##
    bcc less10 ; ##inlineasm##
    sta _e_t1 ; ##inlineasm##
    inc _e_t0 ; ##inlineasm##
.less10 ; ##inlineasm##
    dey ; ##inlineasm##
    bne loop ; ##inlineasm##
    lda _e_t1 ; ##inlineasm##
    ora #'0' ; ##inlineasm##
    pha ; ##inlineasm##
    lda _e_t0 ; ##inlineasm##
    bne div10 ; ##inlineasm##
   ; ##inlineasm##
    pla ; ##inlineasm##
.print ; ##inlineasm##
    jsr &ffee ; OSWRCH ; ##inlineasm##
    pla ; ##inlineasm##
    bne print ; ##inlineasm##
   ; ##inlineasm##
    rts ; ##inlineasm##
} ; ##inlineasm##
   ; ##inlineasm##
  ; AY = signed 16bit number ; ##inlineasm##
.*_e_print_int16 ; ##inlineasm##
{ ; ##inlineasm##
    cmp #&80 ; ##inlineasm##
    sta _e_t3 ; remember (sign of) original number (msb) ; ##inlineasm##
    bcc is_pos ; ##inlineasm##
    ; make negative number positive ; ##inlineasm##
    ; C=1 ; ##inlineasm##
    tya ; ##inlineasm##
    eor #&ff ; ##inlineasm##
    adc #0 ; add 1 (because C=1) ; ##inlineasm##
    tay ; ##inlineasm##
    lda _e_t3 ; ##inlineasm##
    eor #&ff ; ##inlineasm##
    adc #0 ; ##inlineasm##
.is_pos ; ##inlineasm##
    sty _e_t0 ; remember number (made positive), lsb ; ##inlineasm##
    sta _e_t1 ; msb ; ##inlineasm##
    lda #0 ; ##inlineasm##
    pha ; marks end of string on stack ; ##inlineasm##
.div10 ; ##inlineasm##
    lda #0 ; ##inlineasm##
    sta _e_t2 ; collecting decimal digit ; ##inlineasm##
    ldy #16 ; loop counter (16 bits) ; ##inlineasm##
.loop ; ##inlineasm##
    asl _e_t0 ; ##inlineasm##
    rol _e_t1 ; ##inlineasm##
    rol _e_t2 ; ##inlineasm##
    lda _e_t2 ; ##inlineasm##
    sec: sbc #10 ; ##inlineasm##
    bcc less10 ; ##inlineasm##
    sta _e_t2 ; ##inlineasm##
    inc _e_t0 ; ##inlineasm##
.less10 ; ##inlineasm##
    dey ; ##inlineasm##
    bne loop ; ##inlineasm##
    lda _e_t2 ; ##inlineasm##
    ora #'0' ; ##inlineasm##
    pha ; ##inlineasm##
    lda _e_t0 ; ##inlineasm##
    ora _e_t1 ; ##inlineasm##
    bne div10 ; ##inlineasm##
   ; ##inlineasm##
    lda _e_t3 ; was neg? ; ##inlineasm##
    bpl is_pos2 ; ##inlineasm##
    lda #'-' ; ##inlineasm##
    jsr &ffee ; OSWRCH ; ##inlineasm##
.is_pos2 ; ##inlineasm##
    pla ; ##inlineasm##
.print ; ##inlineasm##
    jsr &ffee ; OSWRCH ; ##inlineasm##
    pla ; ##inlineasm##
    bne print ; ##inlineasm##
   ; ##inlineasm##
    rts ; ##inlineasm##
} ; ##inlineasm##
   ; ##inlineasm##
  ; AY = unsigned 16bit number ; ##inlineasm##
.*_e_print_uint16 ; ##inlineasm##
{ ; ##inlineasm##
    sty _e_t0 ; lsb ; ##inlineasm##
    sta _e_t1 ; msb ; ##inlineasm##
    lda #0 ; ##inlineasm##
    pha ; marks end of string on stack ; ##inlineasm##
.div10 ; ##inlineasm##
    lda #0 ; ##inlineasm##
    sta _e_t2 ; collecting decimal digit ; ##inlineasm##
    ldy #16 ; loop counter (16 bits) ; ##inlineasm##
.loop ; ##inlineasm##
    asl _e_t0 ; ##inlineasm##
    rol _e_t1 ; ##inlineasm##
    rol _e_t2 ; ##inlineasm##
    lda _e_t2 ; ##inlineasm##
    sec: sbc #10 ; ##inlineasm##
    bcc less10 ; ##inlineasm##
    sta _e_t2 ; ##inlineasm##
    inc _e_t0 ; ##inlineasm##
.less10 ; ##inlineasm##
    dey ; ##inlineasm##
    bne loop ; ##inlineasm##
    lda _e_t2 ; ##inlineasm##
    ora #'0' ; ##inlineasm##
    pha ; ##inlineasm##
    lda _e_t0 ; ##inlineasm##
    ora _e_t1 ; ##inlineasm##
    bne div10 ; ##inlineasm##
   ; ##inlineasm##
    pla ; ##inlineasm##
.print ; ##inlineasm##
    jsr &ffee ; OSWRCH ; ##inlineasm##
    pla ; ##inlineasm##
    bne print ; ##inlineasm##
   ; ##inlineasm##
    rts ; ##inlineasm##
} ; ##inlineasm##
   ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit___sys_internal
  rts
}
._end_of___sys_internal

._wait
{
  ; space for local variables: 2 byte(s)
  _wait_var_cs=&00ff ; 16bit local variable 'cs' of type 'uint16'
  tsx ; set new frame pointer X
  pha
  pha ; claim space (2 byte(s)) for local variables on stack
   ; ##inlineasm##
      stal _wait_var_cs ; ##inlineasm##
      tya ; ##inlineasm##
      stal _wait_var_cs+1 ; ##inlineasm##
   ; ##inlineasm##
  ldal _wait_var_cs+1
  oral _wait_var_cs
  {: bne if_clause
  jmp else_clause: .if_clause
  jsr _wait_vsync
{
.while_loop
  ldal _wait_var_cs+1
  oral _wait_var_cs
  bne do_while
  jmp end_while: .do_while
  jsr _wait_vsync
  ldal _wait_var_cs ; lsb
  bne *+5 ; do lsb only, skip msb
  decl _wait_var_cs+1 ; msb
  decl _wait_var_cs ; lsb
  jmp while_loop: .end_while: }
 .else_clause
.end_if: }
._exit_wait
  txs ; release stack space (2 byte(s)) for local variables
  rts
}
._end_of_wait

._hook_vsync
{
   ; ##inlineasm##
    { ; ##inlineasm##
      php ; ##inlineasm##
      sei ; ##inlineasm##
      sta _e_t0 ; ##inlineasm##
      lda ___sys_vsync_hook ; ##inlineasm##
      ora ___sys_vsync_hook+1 ; ##inlineasm##
      bne exit ; another hook already active! ; ##inlineasm##
      lda _e_t0 ; ##inlineasm##
      sta ___sys_vsync_hook ; ##inlineasm##
      sty ___sys_vsync_hook+1 ; ##inlineasm##
    .exit ; ##inlineasm##
      plp ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit_hook_vsync
  rts
}
._end_of_hook_vsync

._unhook_vsync
{
   ; ##inlineasm##
      php ; ##inlineasm##
      sei ; ##inlineasm##
      lda #0 ; ##inlineasm##
      sta ___sys_vsync_hook ; ##inlineasm##
      sta ___sys_vsync_hook+1 ; ##inlineasm##
      plp ; ##inlineasm##
   ; ##inlineasm##
._exit_unhook_vsync
  rts
}
._end_of_unhook_vsync

._hook_rtc
{
   ; ##inlineasm##
    { ; ##inlineasm##
      php ; ##inlineasm##
      sei ; ##inlineasm##
      sta _e_t0 ; ##inlineasm##
      lda ___sys_rtc_hook ; ##inlineasm##
      ora ___sys_rtc_hook+1 ; ##inlineasm##
      bne exit ; another hook already active! ; ##inlineasm##
      lda _e_t0 ; ##inlineasm##
      sta ___sys_rtc_hook ; ##inlineasm##
      sty ___sys_rtc_hook+1 ; ##inlineasm##
    .exit ; ##inlineasm##
      plp ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit_hook_rtc
  rts
}
._end_of_hook_rtc

._unhook_rtc
{
   ; ##inlineasm##
      php ; ##inlineasm##
      sei ; ##inlineasm##
      lda #0 ; ##inlineasm##
      sta ___sys_rtc_hook ; ##inlineasm##
      sta ___sys_rtc_hook+1 ; ##inlineasm##
      plp ; ##inlineasm##
   ; ##inlineasm##
._exit_unhook_rtc
  rts
}
._end_of_unhook_rtc

._rnd8
{
  _rnd8_result=&0104 ; 8bit function result of type 'byte'
  tsx ; set new frame pointer X
   ; ##inlineasm##
    { ; ##inlineasm##
      lda __seed ; ##inlineasm##
      asl a ; ##inlineasm##
      bcc no_eor ; ##inlineasm##
      eor #&cf ; ##inlineasm##
    .no_eor ; ##inlineasm##
      sta __seed ; ##inlineasm##
      stal _rnd8_result ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit_rnd8
  rts
}
._end_of_rnd8

._sys_init
{
  jsr _unhook_vsync
  jsr _unhook_rtc
   ; ##inlineasm##
    { ; ##inlineasm##
    php ; ##inlineasm##
    lda &fc ; ##inlineasm##
    sta __seed ; ##inlineasm##
    bne cont ; ##inlineasm##
    inc __seed ; must never init to 0 ; ##inlineasm##
.cont   ; ##inlineasm##
    sei ; ##inlineasm##
    lda &204 ; ##inlineasm##
    sta sm_org_irq1v+1 ; ##inlineasm##
    lda &205 ; ##inlineasm##
    sta sm_org_irq1v+2 ; ##inlineasm##
    lda #0 ; ##inlineasm##
    ldx #1 ; ##inlineasm##
    stx ___sys_is_electron ; assume Acorn Electron ; ##inlineasm##
    jsr &fff4 ; OSBYTE 0 determines host machine: X==0 ==> Electron, X<>0 ==> BBC or something else (assume BBC or similar) ; ##inlineasm##
    txa ; ##inlineasm##
    beq elk ; no need to change flag (default = 1 = Electron), continue ; ##inlineasm##
    dec ___sys_is_electron ; set to 0, because this is NOT an Electron, assume BBC ; ##inlineasm##
    ; beeb ; ##inlineasm##
    ; user timer 1 ; ##inlineasm##
    sei ; ##inlineasm##
    lda #&ff ; ##inlineasm##
    sta &fe64 ; ##inlineasm##
    sta &fe65 ; ##inlineasm##
    lda #0 ; ##inlineasm##
    sta &fe6b ; TIMER 1 in one shot mode ; ##inlineasm##
    sta ___sys_bbctimer ; ##inlineasm##
    lda #%11000000 ; we only want to service these interrupts: TIMER1 (bit6) ; ##inlineasm##
    sta &fe6e ; IER User VIA ; ##inlineasm##
    lda #lo(beeb_irq_handler)   ; ##inlineasm##
    sta &204 ; ##inlineasm##
    lda #hi(beeb_irq_handler) ; ##inlineasm##
    sta &205 ; ##inlineasm##
    plp ; ##inlineasm##
    rts ; ##inlineasm##
   ; ##inlineasm##
.elk ; ##inlineasm##
    sei ; ##inlineasm##
    lda #%00001111 ; RTC, VSYNC ; ##inlineasm##
    sta &fe00 ; IER ; ##inlineasm##
    lda #lo(elk_irq_handler)   ; ##inlineasm##
    sta &204 ; ##inlineasm##
    lda #hi(elk_irq_handler) ; ##inlineasm##
    sta &205 ; ##inlineasm##
    plp ; ##inlineasm##
    rts ; ##inlineasm##
   ; ##inlineasm##
.elk_irq_handler  ; ##inlineasm##
    lda &fe00 ; ##inlineasm##
    and #4 ; ##inlineasm##
    beq check_rtc ; ##inlineasm##
   ; ##inlineasm##
    inc vsync_counter ; ##inlineasm##
   ; ##inlineasm##
    jmp check_vsync_hook ; ##inlineasm##
   ; ##inlineasm##
.check_rtc ; ##inlineasm##
    lda &fe00 ; ##inlineasm##
    and #8 ; ##inlineasm##
    beq exit_int ; ##inlineasm##
   ; ##inlineasm##
    inc rtc_counter ; ##inlineasm##
   ; ##inlineasm##
    jmp check_rtc_hook ; ##inlineasm##
   ; ##inlineasm##
.exit_int ; ##inlineasm##
.sm_org_irq1v ; ##inlineasm##
    jmp &ffff ; SELFMOD   ; ##inlineasm##
   ; ##inlineasm##
.beeb_irq_handler ; ##inlineasm##
    lda &fe4d ; get IFR of System VIA ; ##inlineasm##
    and #2 ; check bit1 (vsync interrupt CA1) ; ##inlineasm##
    beq check_timer1 ; ##inlineasm##
   ; ##inlineasm##
    ; vsync   ; ##inlineasm##
    ; set TIMER1 (one shot) to fire at approx 100th scanline ; ##inlineasm##
    lda #lo(128*64) ; ##inlineasm##
    sta &fe64 ; ##inlineasm##
    lda #hi(128*64) ; ##inlineasm##
    sta &fe65 ; ##inlineasm##
   ; ##inlineasm##
    ; set timer type ; ##inlineasm##
    lsr ___sys_bbctimer ;=0 ; ##inlineasm##
   ; ##inlineasm##
    beq exit_int ; jump always ; ##inlineasm##
   ; ##inlineasm##
.check_timer1 ; ##inlineasm##
    lda &fe6d ; get IFR of User VIA ; ##inlineasm##
    and #&40 ; check bit6 (TIMER1) ; ##inlineasm##
    beq exit_int ; ##inlineasm##
   ; ##inlineasm##
    lda #&40 ; ##inlineasm##
    sta &fe6d ; clear int ; ##inlineasm##
   ; ##inlineasm##
    lda ___sys_bbctimer ; check timer type ; ##inlineasm##
    bne beeb_vsync ; ##inlineasm##
   ; ##inlineasm##
    ; 'rtc' ~100th scanline ; ##inlineasm##
    inc rtc_counter ; ##inlineasm##
   ; ##inlineasm##
    ; set TIMER1 (one shot) to fire after approx 156 scanlines ; ##inlineasm##
    lda #lo(156*64) ; ##inlineasm##
    sta &fe64 ; ##inlineasm##
    lda #hi(156*64) ; ##inlineasm##
    sta &fe65 ; ##inlineasm##
   ; ##inlineasm##
    ; set timer type ; ##inlineasm##
    sec ; ##inlineasm##
    rol ___sys_bbctimer ;=1 ; ##inlineasm##
   ; ##inlineasm##
    jmp check_rtc_hook ; ##inlineasm##
   ; ##inlineasm##
.beeb_vsync ; ##inlineasm##
    ; 'vsync' ~256th scanline ; ##inlineasm##
    inc vsync_counter ; ##inlineasm##
     ; ##inlineasm##
    ; fall through to check_vsync_hook! ; ##inlineasm##
   ; ##inlineasm##
.check_vsync_hook ; ##inlineasm##
    lda ___sys_vsync_hook+1 ; ##inlineasm##
    ora ___sys_vsync_hook ; ##inlineasm##
    bne vsync_hook_defined ; ##inlineasm##
    jmp exit_int ; hook not defined ; ##inlineasm##
.vsync_hook_defined   ; ##inlineasm##
    lda ___sys_vsync_hook ; ##inlineasm##
    sta sm_hook+1 ; ##inlineasm##
    lda ___sys_vsync_hook+1 ; ##inlineasm##
    sta sm_hook+2 ; ##inlineasm##
   ; ##inlineasm##
    jmp exec_hook ; ##inlineasm##
   ; ##inlineasm##
.check_rtc_hook ; ##inlineasm##
    lda ___sys_rtc_hook+1 ; ##inlineasm##
    ora ___sys_rtc_hook ; ##inlineasm##
    bne rtc_hook_defined ; ##inlineasm##
    jmp exit_int ; hook not defined ; ##inlineasm##
.rtc_hook_defined ; ##inlineasm##
    lda ___sys_rtc_hook ; ##inlineasm##
    sta sm_hook+1 ; ##inlineasm##
    lda ___sys_rtc_hook+1 ; ##inlineasm##
    sta sm_hook+2 ; ##inlineasm##
   ; ##inlineasm##
.exec_hook ; ##inlineasm##
    txa: pha: tya: pha ; ##inlineasm##
    lda _e_t0: pha ; ##inlineasm##
    lda _e_t1: pha ; ##inlineasm##
    lda _e_t2: pha ; ##inlineasm##
    lda _e_t3: pha ; ##inlineasm##
    lda _e_t4: pha ; ##inlineasm##
    lda _e_t5: pha ; ##inlineasm##
    lda _e_t6: pha ; ##inlineasm##
    lda _e_t7: pha ; ##inlineasm##
    lda _e_t8: pha ; ##inlineasm##
    lda _e_t9: pha ; ##inlineasm##
.sm_hook ; ##inlineasm##
    jsr &ffff ; SELFMOD ; ##inlineasm##
    pla: sta _e_t9 ; ##inlineasm##
    pla: sta _e_t8 ; ##inlineasm##
    pla: sta _e_t7 ; ##inlineasm##
    pla: sta _e_t6 ; ##inlineasm##
    pla: sta _e_t5 ; ##inlineasm##
    pla: sta _e_t4 ; ##inlineasm##
    pla: sta _e_t3 ; ##inlineasm##
    pla: sta _e_t2 ; ##inlineasm##
    pla: sta _e_t1 ; ##inlineasm##
    pla: sta _e_t0 ; ##inlineasm##
    pla: tay: pla: tax ; ##inlineasm##
   ; ##inlineasm##
    jmp exit_int ; ##inlineasm##
   ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit_sys_init
  rts
}
._end_of_sys_init

._wait_vsync
{
   ; ##inlineasm##
    { ; ##inlineasm##
    lda vsync_counter ; ##inlineasm##
.wait ; ##inlineasm##
    cmp vsync_counter   ; ##inlineasm##
    beq wait ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit_wait_vsync
  rts
}
._end_of_wait_vsync

._wait_rtc
{
   ; ##inlineasm##
    { ; ##inlineasm##
    lda rtc_counter ; ##inlineasm##
.wait ; ##inlineasm##
    cmp rtc_counter   ; ##inlineasm##
    beq wait ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit_wait_rtc
  rts
}
._end_of_wait_rtc

._txt_init
{
._exit_txt_init
  rts
}
._end_of_txt_init

._key
{
  _key_result=&0104 ; 8bit function result of type 'int8'
  tsx ; set new frame pointer X
   ; ##inlineasm##
      stx _e_t0 ; ##inlineasm##
      tax ; ##inlineasm##
      ldy #&ff ; ##inlineasm##
      lda #&81 ; ##inlineasm##
      jsr &fff4 ; OSBYTE ; ##inlineasm##
      ldx _e_t0 ; ##inlineasm##
      tya ; ##inlineasm##
      stal _key_result ; ##inlineasm##
   ; ##inlineasm##
._exit_key
  rts
}
._end_of_key

._defcolour
{
   ; ##inlineasm##
      pha ; ##inlineasm##
      lda #19 ; ##inlineasm##
      jsr &ffee ; OSWRCH (preserves A,X,Y) ; ##inlineasm##
      pla ; ##inlineasm##
      jsr &ffee ; OSWRCH (preserves A,X,Y) ; ##inlineasm##
      tya ; ##inlineasm##
      jsr &ffee ; OSWRCH (preserves A,X,Y) ; ##inlineasm##
      lda #0 ; ##inlineasm##
      jsr &ffee ; OSWRCH (preserves A,X,Y) ; ##inlineasm##
      jsr &ffee ; OSWRCH (preserves A,X,Y) ; ##inlineasm##
      jmp &ffee ; jmp! OSWRCH (preserves A,X,Y) rts from there ; ##inlineasm##
   ; ##inlineasm##
._exit_defcolour
  rts
}
._end_of_defcolour

._cursorto
{
   ; ##inlineasm##
      pha ; ##inlineasm##
      lda #31 ; ##inlineasm##
      jsr &ffee ; OSWRCH (preserves A,X,Y) ; ##inlineasm##
      pla ; ##inlineasm##
      jsr &ffee ; OSWRCH (preserves A,X,Y) ; ##inlineasm##
      tya ; ##inlineasm##
      jmp &ffee ; jmp! OSWRCH (preserves A,X,Y) rts from there ; ##inlineasm##
   ; ##inlineasm##
._exit_cursorto
  rts
}
._end_of_cursorto

._vdu
{
  jmp &ffee ; jmp! OSWRCH (preserves A,X,Y) rts from there ; ##inlineasm##
._exit_vdu
  rts
}
._end_of_vdu

._cursor
{
  ; space for local variables: 2 byte(s)
  _cursor_var_b=&0100 ; 8bit local variable 'b' of type 'byte'
  _cursor_var_i=&00ff ; 8bit local variable 'i' of type 'uint8'
  tsx ; set new frame pointer X
  pha
  pha ; claim space (2 byte(s)) for local variables on stack
  stal _cursor_var_b ; ##inlineasm##
  lda #&17 ; lsb of 23
  jsr _vdu
  lda #&01 ; lsb of 1
  jsr _vdu
  ldal _cursor_var_b
  pha ; lsb
  ldy #&00
  pla
  bne *+3
  dey
  tya
  pha
  ldy #&00
  pla
  bne *+3
  dey
  tya
  and #&01 ; lsb of 1
  jsr _vdu
  lda #&00 ; lsb of 0
  stal _cursor_var_i
{
.while_loop
  ldal _cursor_var_i
  cmp #&07 ; lsb of 7
  bcc do_while
  jmp end_while: .do_while
  lda #&00 ; lsb of 0
  jsr _vdu
  incl _cursor_var_i
  jmp while_loop: .end_while: }
._exit_cursor
  txs ; release stack space (2 byte(s)) for local variables
  rts
}
._end_of_cursor

._gfx_init
{
  lda #&00 ; lsb of 0
  sta ___gfx_x ; lsb
  sta ___gfx_x+1 ; msb
  sta ___gfx_y ; lsb
  sta ___gfx_y+1 ; msb
._exit_gfx_init
  rts
}
._end_of_gfx_init

.___gfx_getpixel_mode_5
{
  ___gfx_getpixel_mode_5_result=&0104 ; 8bit function result of type 'byte'
  ; space for local variables: 5 byte(s)
  ___gfx_getpixel_mode_5_var_x=&0100 ; 8bit local variable 'x' of type 'byte'
  ___gfx_getpixel_mode_5_var_y=&00ff ; 8bit local variable 'y' of type 'byte'
  ___gfx_getpixel_mode_5_var_addr=&00fd ; 16bit local variable 'addr' of type 'word'
  ___gfx_getpixel_mode_5_var_mask=&00fc ; 8bit local variable 'mask' of type 'byte'
  tsx ; set new frame pointer X
  pha
  pha
  pha
  pha
  pha ; claim space (5 byte(s)) for local variables on stack
   ; ##inlineasm##
      stal ___gfx_getpixel_mode_5_var_x ; ##inlineasm##
      tya ; ##inlineasm##
      stal ___gfx_getpixel_mode_5_var_y ; ##inlineasm##
   ; ##inlineasm##
  ldal ___gfx_getpixel_mode_5_var_x
  and #&fc ; lsb of 252
  stal ___gfx_getpixel_mode_5_var_addr ; lsb
  lda #&00
  stal ___gfx_getpixel_mode_5_var_addr+1 ; msb
  pha ; msb
  ldal ___gfx_getpixel_mode_5_var_addr
  asl a
  tay
  pla
  rol a
  pha
  tya
  stal ___gfx_getpixel_mode_5_var_addr ; lsb
  pla
  stal ___gfx_getpixel_mode_5_var_addr+1 ; msb
   ; ##inlineasm##
      ldal ___gfx_getpixel_mode_5_var_y ; ##inlineasm##
      tay ; ##inlineasm##
      ldal ___gfx_getpixel_mode_5_var_addr ; ##inlineasm##
      clc ; ##inlineasm##
      adc mode_4_5_pixelrow_lo,y ; ##inlineasm##
      stal ___gfx_getpixel_mode_5_var_addr ; ##inlineasm##
      ldal ___gfx_getpixel_mode_5_var_addr+1 ; ##inlineasm##
      adc mode_4_5_pixelrow_hi,y ; ##inlineasm##
      stal ___gfx_getpixel_mode_5_var_addr+1 ; ##inlineasm##
   ; ##inlineasm##
      ldal ___gfx_getpixel_mode_5_var_x ; ##inlineasm##
      and #3 ; ##inlineasm##
      tay ; ##inlineasm##
      lda __gfx_bitmask2bpp,y ; ##inlineasm##
      stal ___gfx_getpixel_mode_5_var_mask ; ##inlineasm##
   ; ##inlineasm##
  ldal ___gfx_getpixel_mode_5_var_addr
  sta _e_t0
  ldal ___gfx_getpixel_mode_5_var_addr+1
  sta _e_t1
  ldy #&00
  lda (_e_t0),y ; get byte from address
  andl ___gfx_getpixel_mode_5_var_mask
  stal ___gfx_getpixel_mode_5_result ; pop 8bit value and store in 8bit function result
._exit___gfx_getpixel_mode_5
  txs ; release stack space (5 byte(s)) for local variables
  rts
}
._end_of___gfx_getpixel_mode_5

._mode
{
   ; ##inlineasm##
      tay ; ##inlineasm##
      lda #22 ; ##inlineasm##
      jsr &ffee ; OSWRCH (preserves A,X,Y) ; ##inlineasm##
      tya ; ##inlineasm##
      jmp &ffee ; jmp! OSWRCH (preserves A,X,Y) rts from there ; ##inlineasm##
   ; ##inlineasm##
._exit_mode
  rts
}
._end_of_mode

.___gfx_data
{
  jmp _exit___gfx_data
   ; ##inlineasm##
      .*__gfx_bitmask1bpp ; ##inlineasm##
        equb %10000000 ; ##inlineasm##
        equb %01000000 ; ##inlineasm##
        equb %00100000 ; ##inlineasm##
        equb %00010000 ; ##inlineasm##
        equb %00001000 ; ##inlineasm##
        equb %00000100 ; ##inlineasm##
        equb %00000010 ; ##inlineasm##
        equb %00000001 ; ##inlineasm##
   ; ##inlineasm##
      .*__gfx_bitmask2bpp ; ##inlineasm##
        equb %10001000 ; ##inlineasm##
        equb %01000100 ; ##inlineasm##
        equb %00100010 ; ##inlineasm##
        equb %00010001 ; ##inlineasm##
   ; ##inlineasm##
      .*mode_4_5_pixelrow_lo ; ##inlineasm##
        for n,0,256-1 ; ##inlineasm##
          equb lo(&5800+320*(n div 8)+(n mod 8)) ; ##inlineasm##
        next ;n ; ##inlineasm##
   ; ##inlineasm##
      .*mode_4_5_pixelrow_hi ; ##inlineasm##
        for n,0,256-1 ; ##inlineasm##
          equb hi(&5800+320*(n div 8)+(n mod 8)) ; ##inlineasm##
        next ;n ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
._exit___gfx_data
  rts
}
._end_of___gfx_data

._spr_init
{
  jmp _exit_spr_init
   ; ##inlineasm##
      macro BLITLOOP ; ##inlineasm##
      { ; ##inlineasm##
      .loop ; ##inlineasm##
        lda (___spr_sprite),y ; ##inlineasm##
        beq skip ; ##inlineasm##
        eor (___spr_screen),y ; ##inlineasm##
        sta (___spr_screen),y ; ##inlineasm##
      .skip ; ##inlineasm##
        dey ; ##inlineasm##
        dex ; ##inlineasm##
        bne loop ; ##inlineasm##
      } ; ##inlineasm##
      endmacro ; ##inlineasm##
   ; ##inlineasm##
._exit_spr_init
  rts
}
._end_of_spr_init

.___spr_spriteplot_setup
{
  ; space for parameters: 4 byte(s)
  ___spr_spriteplot_setup_prm_x=&0103 ; 8bit function parameter 'x' of type 'byte'
  ___spr_spriteplot_setup_prm_y=&0104 ; 8bit function parameter 'y' of type 'byte'
  ___spr_spriteplot_setup_prm_sprtable=&0105 ; 16bit function parameter 'sprtable' of type 'word'
  tsx ; set new frame pointer X
   ; ##inlineasm##
    { ; ##inlineasm##
      lda #0 ; ##inlineasm##
      sta ___spr_xcoord+1 ; ##inlineasm##
      ldal ___spr_spriteplot_setup_prm_x ; ##inlineasm##
      sta ___spr_xcoord ; ##inlineasm##
      and #3 ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
    { ; ##inlineasm##
      tay ; ##inlineasm##
      asl ___spr_xcoord ; ##inlineasm##
      rol ___spr_xcoord+1 ; ##inlineasm##
      ldal ___spr_spriteplot_setup_prm_y ; ##inlineasm##
      sta ___spr_ycoord ; ##inlineasm##
      ldal ___spr_spriteplot_setup_prm_sprtable ; ##inlineasm##
      sta ___spr_table ; ##inlineasm##
      ldal ___spr_spriteplot_setup_prm_sprtable+1 ; ##inlineasm##
      sta ___spr_table+1 ; ##inlineasm##
      ; we can use X freely after this because no more access to params and there are no local variables or return value ; ##inlineasm##
      ; Y = 2*(xcoord mod 4) ; ##inlineasm##
      lda (___spr_table),y ; ##inlineasm##
      sta ___spr_sprite ; ##inlineasm##
      iny ; ##inlineasm##
      lda (___spr_table),y ; ##inlineasm##
      sta ___spr_sprite+1 ; ##inlineasm##
      ldy ___spr_ycoord ; ##inlineasm##
      lda ___spr_xcoord ; ##inlineasm##
      and #%11111000 ; ##inlineasm##
      clc ; ##inlineasm##
      adc mode_4_5_pixelrow_lo,y ; ##inlineasm##
      sta ___spr_screen ; ##inlineasm##
      lda ___spr_xcoord+1 ; ##inlineasm##
      adc mode_4_5_pixelrow_hi,y ; ##inlineasm##
      sta ___spr_screen+1 ; ##inlineasm##
      tya ; ##inlineasm##
      and #7 ; ##inlineasm##
      sta ___spr_ymod8 ; ##inlineasm##
      lda #8 ; ##inlineasm##
      sec ; ##inlineasm##
      sbc ___spr_ymod8 ; ##inlineasm##
      sta ___spr_8minusymod8 ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit___spr_spriteplot_setup
  rts
}
._end_of___spr_spriteplot_setup

.___spr_spriteplot12x24_mode_5
{
  ; space for parameters: 4 byte(s)
  ___spr_spriteplot12x24_mode_5_prm_x=&0103 ; 8bit function parameter 'x' of type 'byte'
  ___spr_spriteplot12x24_mode_5_prm_y=&0104 ; 8bit function parameter 'y' of type 'byte'
  ___spr_spriteplot12x24_mode_5_prm_sprtable=&0105 ; 16bit function parameter 'sprtable' of type 'word'
  tsx ; set new frame pointer X
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot_setup' uses its own frameptr X
  ldal ___spr_spriteplot12x24_mode_5_prm_sprtable+1
  pha ; msb
  ldal ___spr_spriteplot12x24_mode_5_prm_sprtable
  pha ; lsb
  ldal ___spr_spriteplot12x24_mode_5_prm_y
  pha ; lsb
  ldal ___spr_spriteplot12x24_mode_5_prm_x
  pha ; lsb
  jsr ___spr_spriteplot_setup
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
   ; ##inlineasm##
    { ; ##inlineasm##
   ; ##inlineasm##
  ; row 1 of 3 ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 3 ; ##inlineasm##
    lda #24-1 ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 3 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 3 of 3 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #lo(320-8) ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    lda ___spr_screen+1 ; ##inlineasm##
    adc #hi(320-8) ; ##inlineasm##
    sta ___spr_screen+1 ; ##inlineasm##
   ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    beq next_row ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 3 ; ##inlineasm##
    ldy #24-1 ; ##inlineasm##
    ; X is still __spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 3 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 3 of 3 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
.next_row ; ##inlineasm##
  ; start of row 2 of 3 ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_sprite ; ##inlineasm##
    adc #24 ; 24 bytes in a row ; ##inlineasm##
    sta ___spr_sprite ; ##inlineasm##
    bcc no_inc_spr ; ##inlineasm##
    inc ___spr_sprite+1 ; ##inlineasm##
    .no_inc_spr ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #8 ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    bcc no_inc_scr ; ##inlineasm##
    inc ___spr_screen+1 ; ##inlineasm##
    .no_inc_scr ; ##inlineasm##
   ; ##inlineasm##
    jmp entry_12x24 ; ##inlineasm##
   ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit___spr_spriteplot12x24_mode_5
  rts
}
._end_of___spr_spriteplot12x24_mode_5

.___spr_spriteplot12x16_mode_5
{
  ; space for parameters: 4 byte(s)
  ___spr_spriteplot12x16_mode_5_prm_x=&0103 ; 8bit function parameter 'x' of type 'byte'
  ___spr_spriteplot12x16_mode_5_prm_y=&0104 ; 8bit function parameter 'y' of type 'byte'
  ___spr_spriteplot12x16_mode_5_prm_sprtable=&0105 ; 16bit function parameter 'sprtable' of type 'word'
  tsx ; set new frame pointer X
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot_setup' uses its own frameptr X
  ldal ___spr_spriteplot12x16_mode_5_prm_sprtable+1
  pha ; msb
  ldal ___spr_spriteplot12x16_mode_5_prm_sprtable
  pha ; lsb
  ldal ___spr_spriteplot12x16_mode_5_prm_y
  pha ; lsb
  ldal ___spr_spriteplot12x16_mode_5_prm_x
  pha ; lsb
  jsr ___spr_spriteplot_setup
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
   ; ##inlineasm##
    { ; ##inlineasm##
   ; ##inlineasm##
  ; row 1 of 2 ; ##inlineasm##
.*entry_12x24 ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 3 ; ##inlineasm##
    lda #24-1 ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 3 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 3 of 3 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #lo(320-8) ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    lda ___spr_screen+1 ; ##inlineasm##
    adc #hi(320-8) ; ##inlineasm##
    sta ___spr_screen+1 ; ##inlineasm##
   ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    beq next_row ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 3 ; ##inlineasm##
    ldy #24-1 ; ##inlineasm##
    ; X is still __spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 3 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 3 of 3 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
.next_row ; ##inlineasm##
  ; row 2 of 2 ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_sprite ; ##inlineasm##
    adc #24 ; 24 bytes in a row ; ##inlineasm##
    sta ___spr_sprite ; ##inlineasm##
    bcc no_inc_spr ; ##inlineasm##
    inc ___spr_sprite+1 ; ##inlineasm##
    .no_inc_spr ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #8 ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    bcc no_inc_scr ; ##inlineasm##
    inc ___spr_screen+1 ; ##inlineasm##
    .no_inc_scr ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 3 ; ##inlineasm##
    lda #24-1 ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 3 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 3 of 3 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #lo(320-8) ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    lda ___spr_screen+1 ; ##inlineasm##
    adc #hi(320-8) ; ##inlineasm##
    sta ___spr_screen+1 ; ##inlineasm##
   ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    beq no_more_rows ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 3 ; ##inlineasm##
    ldy #24-1 ; ##inlineasm##
    ; X is still __spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 3 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 3 of 3 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
.no_more_rows ; ##inlineasm##
   ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit___spr_spriteplot12x16_mode_5
  rts
}
._end_of___spr_spriteplot12x16_mode_5

.___spr_spriteplot16x16_mode_5
{
  ; space for parameters: 4 byte(s)
  ___spr_spriteplot16x16_mode_5_prm_x=&0103 ; 8bit function parameter 'x' of type 'byte'
  ___spr_spriteplot16x16_mode_5_prm_y=&0104 ; 8bit function parameter 'y' of type 'byte'
  ___spr_spriteplot16x16_mode_5_prm_sprtable=&0105 ; 16bit function parameter 'sprtable' of type 'word'
  tsx ; set new frame pointer X
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot_setup' uses its own frameptr X
  ldal ___spr_spriteplot16x16_mode_5_prm_sprtable+1
  pha ; msb
  ldal ___spr_spriteplot16x16_mode_5_prm_sprtable
  pha ; lsb
  ldal ___spr_spriteplot16x16_mode_5_prm_y
  pha ; lsb
  ldal ___spr_spriteplot16x16_mode_5_prm_x
  pha ; lsb
  jsr ___spr_spriteplot_setup
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
   ; ##inlineasm##
    { ; ##inlineasm##
   ; ##inlineasm##
  ; row 1 of 2 ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 4 ; ##inlineasm##
    lda #32-1 ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 4 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 3 of 4 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 4 of 4 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #lo(320-8) ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    lda ___spr_screen+1 ; ##inlineasm##
    adc #hi(320-8) ; ##inlineasm##
    sta ___spr_screen+1 ; ##inlineasm##
   ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    beq next_row ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 4 ; ##inlineasm##
    ldy #32-1 ; ##inlineasm##
    ; X is still __spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 4 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 3 of 4 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 4 of 4 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
.next_row ; ##inlineasm##
  ; row 2 of 2 ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_sprite ; ##inlineasm##
    adc #32 ; 32 bytes in a row ; ##inlineasm##
    sta ___spr_sprite ; ##inlineasm##
    bcc no_inc_spr ; ##inlineasm##
    inc ___spr_sprite+1 ; ##inlineasm##
    .no_inc_spr ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #8 ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    bcc no_inc_scr ; ##inlineasm##
    inc ___spr_screen+1 ; ##inlineasm##
    .no_inc_scr ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 4 ; ##inlineasm##
    lda #32-1 ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 4 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 3 of 4 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 4 of 4 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #lo(320-8) ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    lda ___spr_screen+1 ; ##inlineasm##
    adc #hi(320-8) ; ##inlineasm##
    sta ___spr_screen+1 ; ##inlineasm##
   ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    beq no_more_rows ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 4 ; ##inlineasm##
    ldy #32-1 ; ##inlineasm##
    ; X is still __spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 4 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 3 of 4 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 4 of 4 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
.no_more_rows ; ##inlineasm##
   ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit___spr_spriteplot16x16_mode_5
  rts
}
._end_of___spr_spriteplot16x16_mode_5

.___spr_spriteplot20x24_mode_5
{
  ; space for parameters: 4 byte(s)
  ___spr_spriteplot20x24_mode_5_prm_x=&0103 ; 8bit function parameter 'x' of type 'byte'
  ___spr_spriteplot20x24_mode_5_prm_y=&0104 ; 8bit function parameter 'y' of type 'byte'
  ___spr_spriteplot20x24_mode_5_prm_sprtable=&0105 ; 16bit function parameter 'sprtable' of type 'word'
  tsx ; set new frame pointer X
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot_setup' uses its own frameptr X
  ldal ___spr_spriteplot20x24_mode_5_prm_sprtable+1
  pha ; msb
  ldal ___spr_spriteplot20x24_mode_5_prm_sprtable
  pha ; lsb
  ldal ___spr_spriteplot20x24_mode_5_prm_y
  pha ; lsb
  ldal ___spr_spriteplot20x24_mode_5_prm_x
  pha ; lsb
  jsr ___spr_spriteplot_setup
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
   ; ##inlineasm##
    { ; ##inlineasm##
   ; ##inlineasm##
  ; row 1 of 3 ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 5 ; ##inlineasm##
    lda #40-1 ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 3 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 4 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 5 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #lo(320-8) ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    lda ___spr_screen+1 ; ##inlineasm##
    adc #hi(320-8) ; ##inlineasm##
    sta ___spr_screen+1 ; ##inlineasm##
   ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    beq row2 ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 5 ; ##inlineasm##
    ldy #40-1 ; ##inlineasm##
    ; X is still __spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 3 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 4 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 5 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
.row2 ; ##inlineasm##
  ; row 2 of 3 ; ##inlineasm##
   ; ##inlineasm##
{ ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_sprite ; ##inlineasm##
    adc #40 ; 40 bytes in a row ; ##inlineasm##
    sta ___spr_sprite ; ##inlineasm##
    bcc no_inc_spr ; ##inlineasm##
    inc ___spr_sprite+1 ; ##inlineasm##
    .no_inc_spr ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #8 ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    bcc no_inc_scr ; ##inlineasm##
    inc ___spr_screen+1 ; ##inlineasm##
    .no_inc_scr ; ##inlineasm##
} ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 5 ; ##inlineasm##
    lda #40-1 ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 3 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 4 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 5 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #lo(320-8) ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    lda ___spr_screen+1 ; ##inlineasm##
    adc #hi(320-8) ; ##inlineasm##
    sta ___spr_screen+1 ; ##inlineasm##
   ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    beq row3 ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 5 ; ##inlineasm##
    ldy #40-1 ; ##inlineasm##
    ; X is still __spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 3 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 4 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 5 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
.row3 ; ##inlineasm##
  ; row 3 of 3 ; ##inlineasm##
   ; ##inlineasm##
{ ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_sprite ; ##inlineasm##
    adc #40 ; 40 bytes in a row ; ##inlineasm##
    sta ___spr_sprite ; ##inlineasm##
    bcc no_inc_spr ; ##inlineasm##
    inc ___spr_sprite+1 ; ##inlineasm##
    .no_inc_spr ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #8 ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    bcc no_inc_scr ; ##inlineasm##
    inc ___spr_screen+1 ; ##inlineasm##
    .no_inc_scr ; ##inlineasm##
} ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 5 ; ##inlineasm##
    lda #40-1 ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 3 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 4 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 5 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #lo(320-8) ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    lda ___spr_screen+1 ; ##inlineasm##
    adc #hi(320-8) ; ##inlineasm##
    sta ___spr_screen+1 ; ##inlineasm##
   ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    beq done ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 5 ; ##inlineasm##
    ldy #40-1 ; ##inlineasm##
    ; X is still __spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 3 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 4 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 5 of 5 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
.done ; ##inlineasm##
   ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit___spr_spriteplot20x24_mode_5
  rts
}
._end_of___spr_spriteplot20x24_mode_5

.___spr_spriteplot8x24_mode_5
{
  ; space for parameters: 4 byte(s)
  ___spr_spriteplot8x24_mode_5_prm_x=&0103 ; 8bit function parameter 'x' of type 'byte'
  ___spr_spriteplot8x24_mode_5_prm_y=&0104 ; 8bit function parameter 'y' of type 'byte'
  ___spr_spriteplot8x24_mode_5_prm_sprtable=&0105 ; 16bit function parameter 'sprtable' of type 'word'
  tsx ; set new frame pointer X
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot_setup' uses its own frameptr X
  ldal ___spr_spriteplot8x24_mode_5_prm_sprtable+1
  pha ; msb
  ldal ___spr_spriteplot8x24_mode_5_prm_sprtable
  pha ; lsb
  ldal ___spr_spriteplot8x24_mode_5_prm_y
  pha ; lsb
  ldal ___spr_spriteplot8x24_mode_5_prm_x
  pha ; lsb
  jsr ___spr_spriteplot_setup
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
   ; ##inlineasm##
    { ; ##inlineasm##
   ; ##inlineasm##
  ; row 1 of 3 ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 2 ; ##inlineasm##
    lda #16-1 ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 2 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #lo(320-8) ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    lda ___spr_screen+1 ; ##inlineasm##
    adc #hi(320-8) ; ##inlineasm##
    sta ___spr_screen+1 ; ##inlineasm##
   ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    beq next_row ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 2 ; ##inlineasm##
    ldy #16-1 ; ##inlineasm##
    ; X is still __spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 2 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
.next_row ; ##inlineasm##
  ; row 2 of 2 ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_sprite ; ##inlineasm##
    adc #16 ; 16 bytes in a row ; ##inlineasm##
    sta ___spr_sprite ; ##inlineasm##
    bcc no_inc_spr ; ##inlineasm##
    inc ___spr_sprite+1 ; ##inlineasm##
    .no_inc_spr ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #8 ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    bcc no_inc_scr ; ##inlineasm##
    inc ___spr_screen+1 ; ##inlineasm##
    .no_inc_scr ; ##inlineasm##
   ; ##inlineasm##
    jmp entry_8x24 ; ##inlineasm##
   ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit___spr_spriteplot8x24_mode_5
  rts
}
._end_of___spr_spriteplot8x24_mode_5

.___spr_spriteplot8x16_mode_5
{
  ; space for parameters: 4 byte(s)
  ___spr_spriteplot8x16_mode_5_prm_x=&0103 ; 8bit function parameter 'x' of type 'byte'
  ___spr_spriteplot8x16_mode_5_prm_y=&0104 ; 8bit function parameter 'y' of type 'byte'
  ___spr_spriteplot8x16_mode_5_prm_sprtable=&0105 ; 16bit function parameter 'sprtable' of type 'word'
  tsx ; set new frame pointer X
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot_setup' uses its own frameptr X
  ldal ___spr_spriteplot8x16_mode_5_prm_sprtable+1
  pha ; msb
  ldal ___spr_spriteplot8x16_mode_5_prm_sprtable
  pha ; lsb
  ldal ___spr_spriteplot8x16_mode_5_prm_y
  pha ; lsb
  ldal ___spr_spriteplot8x16_mode_5_prm_x
  pha ; lsb
  jsr ___spr_spriteplot_setup
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
   ; ##inlineasm##
    { ; ##inlineasm##
   ; ##inlineasm##
.*entry_8x24 ; __spr_spriteplot8x24_mode_5() jumps here ; ##inlineasm##
   ; ##inlineasm##
  ; row 1 of 2 ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 2 ; ##inlineasm##
    lda #16-1 ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 2 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #lo(320-8) ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    lda ___spr_screen+1 ; ##inlineasm##
    adc #hi(320-8) ; ##inlineasm##
    sta ___spr_screen+1 ; ##inlineasm##
   ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    beq next_row ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 2 ; ##inlineasm##
    ldy #16-1 ; ##inlineasm##
    ; X is still __spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 2 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
.next_row ; ##inlineasm##
  ; row 2 of 2 ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_sprite ; ##inlineasm##
    adc #16 ; 16 bytes in a row ; ##inlineasm##
    sta ___spr_sprite ; ##inlineasm##
    bcc no_inc_spr ; ##inlineasm##
    inc ___spr_sprite+1 ; ##inlineasm##
    .no_inc_spr ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #8 ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    bcc no_inc_scr ; ##inlineasm##
    inc ___spr_screen+1 ; ##inlineasm##
    .no_inc_scr ; ##inlineasm##
   ; ##inlineasm##
    jmp entry_8x16 ; ##inlineasm##
   ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit___spr_spriteplot8x16_mode_5
  rts
}
._end_of___spr_spriteplot8x16_mode_5

.___spr_spriteplot4x16_mode_5
{
  ; space for parameters: 4 byte(s)
  ___spr_spriteplot4x16_mode_5_prm_x=&0103 ; 8bit function parameter 'x' of type 'byte'
  ___spr_spriteplot4x16_mode_5_prm_y=&0104 ; 8bit function parameter 'y' of type 'byte'
  ___spr_spriteplot4x16_mode_5_prm_sprtable=&0105 ; 16bit function parameter 'sprtable' of type 'word'
  tsx ; set new frame pointer X
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot_setup' uses its own frameptr X
  ldal ___spr_spriteplot4x16_mode_5_prm_sprtable+1
  pha ; msb
  ldal ___spr_spriteplot4x16_mode_5_prm_sprtable
  pha ; lsb
  ldal ___spr_spriteplot4x16_mode_5_prm_y
  pha ; lsb
  ldal ___spr_spriteplot4x16_mode_5_prm_x
  pha ; lsb
  jsr ___spr_spriteplot_setup
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
   ; ##inlineasm##
    { ; ##inlineasm##
   ; ##inlineasm##
  ; row 1 of 2 ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 1 ; ##inlineasm##
    lda #8-1 ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #lo(320-8) ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    lda ___spr_screen+1 ; ##inlineasm##
    adc #hi(320-8) ; ##inlineasm##
    sta ___spr_screen+1 ; ##inlineasm##
   ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    beq next_row ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 1 ; ##inlineasm##
    ldy #8-1 ; ##inlineasm##
    ; X is still __spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
.next_row ; ##inlineasm##
  ; row 2 of 2 ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_sprite ; ##inlineasm##
    adc #8 ; 8 bytes in a row ; ##inlineasm##
    sta ___spr_sprite ; ##inlineasm##
    bcc no_inc_spr ; ##inlineasm##
    inc ___spr_sprite+1 ; ##inlineasm##
    .no_inc_spr ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #8 ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    bcc no_inc_scr ; ##inlineasm##
    inc ___spr_screen+1 ; ##inlineasm##
    .no_inc_scr ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 1 ; ##inlineasm##
    lda #8-1 ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #lo(320-8) ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    lda ___spr_screen+1 ; ##inlineasm##
    adc #hi(320-8) ; ##inlineasm##
    sta ___spr_screen+1 ; ##inlineasm##
   ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    beq no_more_rows ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 1 ; ##inlineasm##
    ldy #8-1 ; ##inlineasm##
    ; X is still __spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
.no_more_rows ; ##inlineasm##
   ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit___spr_spriteplot4x16_mode_5
  rts
}
._end_of___spr_spriteplot4x16_mode_5

.___spr_spriteplot8x8_mode_5
{
  ; space for parameters: 4 byte(s)
  ___spr_spriteplot8x8_mode_5_prm_x=&0103 ; 8bit function parameter 'x' of type 'byte'
  ___spr_spriteplot8x8_mode_5_prm_y=&0104 ; 8bit function parameter 'y' of type 'byte'
  ___spr_spriteplot8x8_mode_5_prm_sprtable=&0105 ; 16bit function parameter 'sprtable' of type 'word'
  tsx ; set new frame pointer X
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot_setup' uses its own frameptr X
  ldal ___spr_spriteplot8x8_mode_5_prm_sprtable+1
  pha ; msb
  ldal ___spr_spriteplot8x8_mode_5_prm_sprtable
  pha ; lsb
  ldal ___spr_spriteplot8x8_mode_5_prm_y
  pha ; lsb
  ldal ___spr_spriteplot8x8_mode_5_prm_x
  pha ; lsb
  jsr ___spr_spriteplot_setup
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
   ; ##inlineasm##
    { ; ##inlineasm##
   ; ##inlineasm##
.*entry_8x16 ; __spr_spriteplot8x16_mode_5() jumps here ; ##inlineasm##
   ; ##inlineasm##
  ; row 1 of 1 ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 2 ; ##inlineasm##
    lda #16-1 ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 2 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_ymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_8minusymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    clc ; ##inlineasm##
    lda ___spr_screen ; ##inlineasm##
    adc #lo(320-8) ; ##inlineasm##
    sta ___spr_screen ; ##inlineasm##
    lda ___spr_screen+1 ; ##inlineasm##
    adc #hi(320-8) ; ##inlineasm##
    sta ___spr_screen+1 ; ##inlineasm##
   ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    beq no_more_rows ; ##inlineasm##
   ; ##inlineasm##
    ; column 1 of 2 ; ##inlineasm##
    ldy #16-1 ; ##inlineasm##
    ; X is still __spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
    ; column 2 of 2 ; ##inlineasm##
    tya ; ##inlineasm##
    sec ; ##inlineasm##
    sbc ___spr_8minusymod8 ; ##inlineasm##
    tay ; ##inlineasm##
    ldx ___spr_ymod8 ; ##inlineasm##
    BLITLOOP ; ##inlineasm##
   ; ##inlineasm##
.no_more_rows ; ##inlineasm##
   ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit___spr_spriteplot8x8_mode_5
  rts
}
._end_of___spr_spriteplot8x8_mode_5

._snd_init
{
._exit_snd_init
  rts
}
._end_of_snd_init

._qsound
{
  ; space for parameters: 3 byte(s)
  _qsound_prm_channel=&0103 ; 8bit function parameter 'channel' of type 'byte'
  _qsound_prm_pitch=&0104 ; 8bit function parameter 'pitch' of type 'byte'
  _qsound_prm_duration=&0105 ; 8bit function parameter 'duration' of type 'byte'
  ; space for local variables: 4 byte(s)
  _qsound_var_sound_volume=&00ff ; 16bit local variable 'sound_volume' of type 'int'
  _qsound_var_music_volume=&00fd ; 16bit local variable 'music_volume' of type 'int'
  tsx ; set new frame pointer X
  pha
  pha
  pha
  pha ; claim space (4 byte(s)) for local variables on stack
  lda #&f4 ; lsb of -12
  pha
  ldy #&00
  pla
  bpl *+3
  dey
  stal _qsound_var_sound_volume ; lsb
  tya
  stal _qsound_var_sound_volume+1 ; msb
  lda #&f6 ; lsb of -10
  pha
  ldy #&00
  pla
  bpl *+3
  dey
  stal _qsound_var_music_volume ; lsb
  tya
  stal _qsound_var_music_volume+1 ; msb
{ ; ##inlineasm##
  ldal _qsound_prm_channel
  cmp #&01 ; lsb of 1
  {: beq if_clause
  jmp else_clause: .if_clause
   ; ##inlineasm##
        ldal _qsound_var_music_volume ; ##inlineasm##
        sta __snd_amplitude ; ##inlineasm##
        ldal _qsound_var_music_volume+1 ; ##inlineasm##
        sta __snd_amplitude+1 ; ##inlineasm##
   ; ##inlineasm##
  jmp end_if: .else_clause
   ; ##inlineasm##
        ldal _qsound_var_sound_volume ; ##inlineasm##
        sta __snd_amplitude ; ##inlineasm##
        ldal _qsound_var_sound_volume+1 ; ##inlineasm##
        sta __snd_amplitude+1 ; ##inlineasm##
   ; ##inlineasm##
.end_if: }
   ; ##inlineasm##
      ldal _qsound_prm_pitch ; ##inlineasm##
      sta __snd_pitch ; ##inlineasm##
      bne dur ; ##inlineasm##
      lda #0 ; ##inlineasm##
      sta __snd_amplitude ; ##inlineasm##
      sta __snd_amplitude+1 ; set vol=0 when pitch was 0 (i.e. pause) ; ##inlineasm##
.dur ; ##inlineasm##
      ldal _qsound_prm_duration ; ##inlineasm##
      sta __snd_duration ; ##inlineasm##
      ldal _qsound_prm_channel ; ##inlineasm##
      sta __snd_channel ; ##inlineasm##
      txa: pha ; ##inlineasm##
      ldy #hi(__snd_osword_block) ; ##inlineasm##
      ldx #lo(__snd_osword_block) ; ##inlineasm##
      lda #7 ; indicates OSWORD SOUND ; ##inlineasm##
      jsr &fff1 ; OSWORD ; ##inlineasm##
      pla: tax ; ##inlineasm##
      jmp exit ; ##inlineasm##
    .__snd_osword_block ; ##inlineasm##
    .__snd_channel equw 0 ; ##inlineasm##
    .__snd_amplitude equw 0 ; ##inlineasm##
    .__snd_pitch equw 0 ; ##inlineasm##
    .__snd_duration equw 0 ; ##inlineasm##
    .exit ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit_qsound
  txs ; release stack space (4 byte(s)) for local variables
  rts
}
._end_of_qsound

._data
{
  jmp _exit_data
  equs " Python " ; ##inlineasm##
  equs "v0.4a" ; ##inlineasm##
  equs " - Copyright (c) 2021-2022 0xC0DE (@0xC0DE6502) " ; ##inlineasm##
.*str_copyright ; ##inlineasm##
  equs "V\^@A" ; ##inlineasm##
   ; ##inlineasm##
      equs " BY \XC\DE", 0 ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
    .*digits_sprites ; ##inlineasm##
      incbin "gfx/digits_8x8x10.bin" ; ##inlineasm##
   ; ##inlineasm##
    .*str_score ; ##inlineasm##
      equs "SCORE", 0 ; ##inlineasm##
   ; ##inlineasm##
    .*str_00000 ; ##inlineasm##
      equs "\\\\\", 0 ; \=0 ; ##inlineasm##
   ; ##inlineasm##
    .*str_time ; ##inlineasm##
      equs "TIME", 0 ; ##inlineasm##
   ; ##inlineasm##
    .*str_level ; ##inlineasm##
      equs "LVL", 0 ; ##inlineasm##
   ; ##inlineasm##
    .*str_lives ; ##inlineasm##
      equs "LIVES", 0 ; ##inlineasm##
   ; ##inlineasm##
    .*str_nameofgame  ; ##inlineasm##
      equs "PYTHON", 0 ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
    .*str_left ; ##inlineasm##
      equs "Z _ LEFT", 0 ; _=- ; ##inlineasm##
   ; ##inlineasm##
    .*str_right ; ##inlineasm##
      equs "X _ RIGHT", 0 ; _=- ; ##inlineasm##
   ; ##inlineasm##
    .*str_up ; ##inlineasm##
      equs "[ _ UP", 0 ; [=:, _=- ; ##inlineasm##
   ; ##inlineasm##
    .*str_down ; ##inlineasm##
      equs "] _ DOWN", 0 ; ]=/, _=- ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
    .*str_musiconoff ; ##inlineasm##
      equs "M _ MUSIC", 0 ; _=- ; ##inlineasm##
   ; ##inlineasm##
    .*str_spacetoplay ; ##inlineasm##
      equs "SPACE TO PLAY", 0 ; ##inlineasm##
   ; ##inlineasm##
    .*str_hiscore ; ##inlineasm##
      equs "HI[", 0 ; [=: ; ##inlineasm##
   ; ##inlineasm##
    .*tiles ; ##inlineasm##
      equb '/', '=', '\', '|', 'J', 'L', 'T', ']', 'U', '[', '.', '{', ''', '}', '+', 'O' ; ##inlineasm##
   ; ##inlineasm##
    .*levels ; ##inlineasm##
      equw intro_screen ; ##inlineasm##
      equw level1 ; ##inlineasm##
      equw level2 ; ##inlineasm##
      equw level3 ; ##inlineasm##
      equw level4 ; ##inlineasm##
      equw level5 ; ##inlineasm##
      equw level6 ; ##inlineasm##
      equw level7 ; ##inlineasm##
      equw level8 ; ##inlineasm##
   ; ##inlineasm##
      ; &&&& Notes on level design: ; ##inlineasm##
      ; Levels must have at least 1 diamond ; ##inlineasm##
      ; Levels must not have too many diamonds or the python tail will misbehave (trail stores up to 256 movements) ; ##inlineasm##
      ; Levels must not open spaces or sharp turns because the python tail will misbehave when turning a corner ; ##inlineasm##
      ; Check the example levels for inspiration ; ##inlineasm##
   ; ##inlineasm##
    .*intro_screen ; 15 lines of 20 chars ; ##inlineasm##
      equs "/==================\" ; ##inlineasm##
      equs "| ***          *** |" ; ##inlineasm##
      equs "|                  |" ; ##inlineasm##
      equs "L==.============.==J" ; ##inlineasm##
      equs "   |            |   " ; ##inlineasm##
      equs "/=='============'==\" ; ##inlineasm##
      equs "|                  |" ; ##inlineasm##
      equs "|                  |" ; ##inlineasm##
      equs "|                  |" ; ##inlineasm##
      equs "|                  |" ; ##inlineasm##
      equs "|                  |" ; ##inlineasm##
      equs "|                  |" ; ##inlineasm##
      equs "|                  |" ; ##inlineasm##
      equs "L==================J" ; ##inlineasm##
      equs "                    " ; ##inlineasm##
     ; ##inlineasm##
    .*level1 ; 15 lines of 20 chars ; ##inlineasm##
      equs "/==================\" ; ##inlineasm##
      equs "|*    *     *     *|" ; ##inlineasm##
      equs "| /======\ /=====\ |" ; ##inlineasm##
      equs "| |      | |     | |" ; ##inlineasm##
      equs "| |      |*|     | |" ; ##inlineasm##
      equs "|*|      | |     |*|" ; ##inlineasm##
      equs "| L======J L=====J |" ; ##inlineasm##
      equs "|   *     *     *  |" ; ##inlineasm##
      equs "| /=.=.==\ /=====\ |" ; ##inlineasm##
      equs "|*| |*|  | |     | |" ; ##inlineasm##
      equs "| | |*|  |*|     | |" ; ##inlineasm##
      equs "| | |*|  | |     |*|" ; ##inlineasm##
      equs "| L=J*L==J L=====J |" ; ##inlineasm##
      equs "|*     *           |" ; ##inlineasm##
      equs "L==================J" ; ##inlineasm##
   ; ##inlineasm##
    .*level2 ; 15 lines of 20 chars ; ##inlineasm##
      equs "/==================\" ; ##inlineasm##
      equs "|  *          *    |" ; ##inlineasm##
      equs "| [==]*O*[=======] |" ; ##inlineasm##
      equs "|   *     *      * |" ; ##inlineasm##
      equs "|*[========]*[===\ |" ; ##inlineasm##
      equs "|     *   *     *| |" ; ##inlineasm##
      equs "| O /==========\ |*|" ; ##inlineasm##
      equs "| * |          | U |" ; ##inlineasm##
      equs "| T |          | * |" ; ##inlineasm##
      equs "|*| L==========J T |" ; ##inlineasm##
      equs "| |*   *     *   | |" ; ##inlineasm##
      equs "|*}======\ /====={*|" ; ##inlineasm##
      equs "| L======J*L=====J |" ; ##inlineasm##
      equs "| *    *           |" ; ##inlineasm##
      equs "L==================J" ; ##inlineasm##
   ; ##inlineasm##
    .*level3 ; 15 lines of 20 chars ; ##inlineasm##
      equs "/================.=\" ; ##inlineasm##
      equs "|  *    *     *  | |" ; ##inlineasm##
      equs "| [============] | |" ; ##inlineasm##
      equs "|  *         *   | |" ; ##inlineasm##
      equs "| [==]*[]*[======J |" ; ##inlineasm##
      equs "|  *              *|" ; ##inlineasm##
      equs "| [=.=======]*[==] |" ; ##inlineasm##
      equs "| * |   *         *|" ; ##inlineasm##
      equs "| O | [=====]*[===={" ; ##inlineasm##
      equs "| * |*   *      *  |" ; ##inlineasm##
      equs "| T L====] [=====] |" ; ##inlineasm##
      equs "| |       *        |" ; ##inlineasm##
      equs "| | O*O [===] O*[] |" ; ##inlineasm##
      equs "| |*               |" ; ##inlineasm##
      equs "L='================J" ; ##inlineasm##
   ; ##inlineasm##
    .*level4 ; 15 lines of 20 chars ; ##inlineasm##
      equs "/==================\" ; ##inlineasm##
      equs "|  *   *       *   |" ; ##inlineasm##
      equs "| /=====]*[======\ |" ; ##inlineasm##
      equs "|*|*         *   |*|" ; ##inlineasm##
      equs "| | T*[========\ | |" ; ##inlineasm##
      equs "| | |    *     |*|*|" ; ##inlineasm##
      equs "| U }========]*| U |" ; ##inlineasm##
      equs "| * |    *     | * |" ; ##inlineasm##
      equs "| T | [========J T |" ; ##inlineasm##
      equs "| | |  *    *    | |" ; ##inlineasm##
      equs "|*| L==========] |*|" ; ##inlineasm##
      equs "| |*   *    *   *| |" ; ##inlineasm##
      equs "| L=====]*[======J |" ; ##inlineasm##
      equs "|*   *            *|" ; ##inlineasm##
      equs "L==================J" ; ##inlineasm##
   ; ##inlineasm##
    .*level5 ; 15 lines of 20 chars ; ##inlineasm##
      equs "/=========.========\" ; ##inlineasm##
      equs "|*   *   *|*   *   |" ; ##inlineasm##
      equs "|*T /===] | [====\*|" ; ##inlineasm##
      equs "}=J | *   | *    | |" ; ##inlineasm##
      equs "| * | [===+====]*| |" ; ##inlineasm##
      equs "| T |*    |  *   |*|" ; ##inlineasm##
      equs "| | L===]*U [==] U |" ; ##inlineasm##
      equs "|*|  *        *    |" ; ##inlineasm##
      equs "| L==============]*|" ; ##inlineasm##
      equs "|  *           *   |" ; ##inlineasm##
      equs "}=====]*/==]*[====={" ; ##inlineasm##
      equs "|   *   |          |" ; ##inlineasm##
      equs "| [===] }========] |" ; ##inlineasm##
      equs "|  *    |          |" ; ##inlineasm##
      equs "L======='==========J" ; ##inlineasm##
   ; ##inlineasm##
    .*level6 ; 15 lines of 20 chars ; ##inlineasm##
      equs "/==========.===.===\" ; ##inlineasm##
      equs "|     *    | * | * |" ; ##inlineasm##
      equs "|*O*[==\ T*U T U T |" ; ##inlineasm##
      equs "|    * |*|  *|*  |*|" ; ##inlineasm##
      equs "| /==\ | U [='=] U |" ; ##inlineasm##
      equs "|*|  |*|  *    *   |" ; ##inlineasm##
      equs "| |  | U [==\*[===={" ; ##inlineasm##
      equs "|*|  |   *  |    * |" ; ##inlineasm##
      equs "| L=='.===] L==] T |" ; ##inlineasm##
      equs "|*    | *    *   | |" ; ##inlineasm##
      equs "}===] | [======] |*|" ; ##inlineasm##
      equs "|  *  |  *      *| |" ; ##inlineasm##
      equs "|*[===J [===]*[==J |" ; ##inlineasm##
      equs "|  *              *|" ; ##inlineasm##
      equs "L==================J" ; ##inlineasm##
   ; ##inlineasm##
    .*level7 ; 15 lines of 20 chars ; ##inlineasm##
      equs "/====.=============\" ; ##inlineasm##
      equs "| *  |  *     *   *|" ; ##inlineasm##
      equs "| /\*| /===\*[===] |" ; ##inlineasm##
      equs "|*|| U | * |   *   |" ; ##inlineasm##
      equs "| || * | T |*/===] |" ; ##inlineasm##
      equs "| LJ T U | U |*    |" ; ##inlineasm##
      equs "| *  |*  | * | /=.={" ; ##inlineasm##
      equs "}==] L===+===J | |*|" ; ##inlineasm##
      equs "|     *  |  *  | |*|" ; ##inlineasm##
      equs "|*[====] | [=] L=J |" ; ##inlineasm##
      equs "| *     *| *       |" ; ##inlineasm##
      equs "| T /===='=====\*T |" ; ##inlineasm##
      equs "| U*L==========J U |" ; ##inlineasm##
      equs "|*    *           *|" ; ##inlineasm##
      equs "L==================J" ; ##inlineasm##
   ; ##inlineasm##
    .*level8 ; 15 lines of 20 chars ; ##inlineasm##
      equs "/==================\" ; ##inlineasm##
      equs "|  *   *      *   *|" ; ##inlineasm##
      equs "| [=] O O*O T O [] |" ; ##inlineasm##
      equs "|*   *      |    * |" ; ##inlineasm##
      equs "}===] O O O*U O [=={" ; ##inlineasm##
      equs "|  *    *         *|" ; ##inlineasm##
      equs "| O T O O O*O O [] |" ; ##inlineasm##
      equs "|   |  *         * |" ; ##inlineasm##
      equs "}=] U O O*O*O O [] |" ; ##inlineasm##
      equs "|*    *       *   *|" ; ##inlineasm##
      equs "| O O O O*[=\*O [] |" ; ##inlineasm##
      equs "|   *       |   *  |" ; ##inlineasm##
      equs "|*[=] O*O O*U O []*|" ; ##inlineasm##
      equs "|    *             |" ; ##inlineasm##
      equs "L==================J" ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
    .*tiles_8x16x16_sprites ; ##inlineasm##
      for n,0,16-1 ; ##inlineasm##
        equw (&400+n*((8*16)/4)) ; &&&& 512 bytes moved down to &400!! ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .*corner_up_left_8x16x8_sprites ; ##inlineasm##
      for n,0,8-1 ; ##inlineasm##
        equw (&600+n*((8*16)/4)) ; &&&& 256 bytes moved down to &600!! ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .*corner_up_right_8x16x8_sprites ; ##inlineasm##
      for n,0,8-1 ; ##inlineasm##
        equw (&700+n*((8*16)/4)) ; &&&& 256 bytes moved down to &700!! ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .*corner_down_left_8x16x8_sprites ; ##inlineasm##
      for n,0,8-1 ; ##inlineasm##
        equw (&a00+n*((8*16)/4)) ; &&&& 256 bytes moved down to &A00!! ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .*corner_down_right_8x16x8_sprites ; ##inlineasm##
      for n,0,8-1 ; ##inlineasm##
        equw (&b00+n*((8*16)/4)) ; &&&& 256 bytes moved down to &B00!! ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .*tune_data ; ##inlineasm##
      ;    B3 A3 B3 F3# D3 F3# B2 ; ##inlineasm##
      equb 97,89,97,77, 61,77, 49,0 ; ##inlineasm##
      ;    B3 A3 B3 F3# D3 F3# B2 ; ##inlineasm##
      equb 97,89,97,77, 61,77, 49,0 ; ##inlineasm##
      ;    B3 C4#  D4 C4#  D4 B3 C4# B3 C4# A3 B3 A3 B3 G3 B3 ; ##inlineasm##
      equb 97,105,109,105,109,97,105,97,105,89,97,89,97,81,97,0 ; ##inlineasm##
      ;    B3 A3 B3 F3# D3 F3# B2 ; ##inlineasm##
      equb 97,89,97,77, 61,77, 49,0 ; ##inlineasm##
      ;    B3 A3 B3 F3# D3 F3# B2 ; ##inlineasm##
      equb 97,89,97,77, 61,77, 49,0 ; ##inlineasm##
      ;    B3 C4#  D4 C4#  D4 B3 C4# B3 C4# A3 B3 A3 B3 C4#  D4 ; ##inlineasm##
      equb 97,105,109,105,109,97,105,97,105,89,97,89,97,105,109,0 ; ##inlineasm##
      ;    F4#  E4 F4#  D4 A3  D4 F3# ; ##inlineasm##
      equb 125,117,125,109,89,109,77, 0 ; ##inlineasm##
      ;    F4#  E4 F4#  D4 A3  D4 F3# ; ##inlineasm##
      equb 125,117,125,109,89,109,77, 0 ; ##inlineasm##
      ;    F4# G4#  A4 G4#  A4 F4# G4# F4# G4#  E4 F4#  E4 F4#  D4 F4# ; ##inlineasm##
      equb 125,133,137,133,137,125,133,125,133,117,125,117,125,109,125,0 ; ##inlineasm##
      ;    F4#  E4 F4#  D4 A3  D4 F3# ; ##inlineasm##
      equb 125,117,125,109,89,109,77, 0 ; ##inlineasm##
      ;    F4#  E4 F4#  D4 A3  D4 F3# ; ##inlineasm##
      equb 125,117,125,109,89,109,77, 0 ; ##inlineasm##
      ;    F4# G4#  A4 G4#  A4 F4# G4# F4# G4#  E4 F4#  E4  D4  E4 F4# ; ##inlineasm##
      equb 125,133,137,133,137,125,133,125,133,117,125,117,109,117,125,0 ; ##inlineasm##
      equb -1 ; end of tune (repeat) ; ##inlineasm##
   ; ##inlineasm##
    .letters_symbols_8x8x32 ; ##inlineasm##
      incbin "gfx/letters_symbols_8x8x32.bin" ; ##inlineasm##
    .*letters_symbols_8x8x32_sprites ; ##inlineasm##
      for n,0,32-1 ; ##inlineasm##
        equw (letters_symbols_8x8x32+n*((8*8)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .diamond_8x16x1 ; ##inlineasm##
      incbin "gfx/diamond_8x16x1.bin" ; ##inlineasm##
    .*diamond_8x16x1_sprites ; ##inlineasm##
      for n,0,1-1 ; ##inlineasm##
        equw (diamond_8x16x1+n*((8*16)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .head_up_8x16x1 ; ##inlineasm##
      incbin "gfx/head_up_8x16x1.bin" ; ##inlineasm##
    .*head_up_8x16x1_sprites ; ##inlineasm##
      for n,0,1-1 ; ##inlineasm##
        equw (head_up_8x16x1+n*((8*16)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .head_down_8x16x1 ; ##inlineasm##
      incbin "gfx/head_down_8x16x1.bin" ; ##inlineasm##
    .*head_down_8x16x1_sprites ; ##inlineasm##
      for n,0,1-1 ; ##inlineasm##
        equw (head_down_8x16x1+n*((8*16)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .head_left_12x16x2 ; ##inlineasm##
      incbin "gfx/head_left_12x16x2.bin" ; ##inlineasm##
    .*head_left_12x16x2_sprites ; ##inlineasm##
      for n,0,2-1 ; ##inlineasm##
        equw (head_left_12x16x2+n*((12*16)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .head_right_12x16x2 ; ##inlineasm##
      incbin "gfx/head_right_12x16x2.bin" ; ##inlineasm##
    .*head_right_12x16x2_sprites ; ##inlineasm##
      for n,0,2-1 ; ##inlineasm##
        equw (head_right_12x16x2+n*((12*16)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
    .body_up_8x8x3 ; ##inlineasm##
      incbin "gfx/body_up_8x8x3.bin" ; ##inlineasm##
    .*body_up_8x8x3_sprites ; ##inlineasm##
      for n,0,3-1 ; ##inlineasm##
        equw (body_up_8x8x3+n*((8*8)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .body_down_8x8x3 ; ##inlineasm##
      incbin "gfx/body_down_8x8x3.bin" ; ##inlineasm##
    .*body_down_8x8x3_sprites ; ##inlineasm##
      for n,0,3-1 ; ##inlineasm##
        equw (body_down_8x8x3+n*((8*8)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .body_left_4x16x3 ; ##inlineasm##
      incbin "gfx/body_left_4x16x3.bin" ; ##inlineasm##
    .*body_left_4x16x3_sprites ; ##inlineasm##
      for n,0,3-1 ; ##inlineasm##
        equw (body_left_4x16x3+n*((4*16)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .body_right_4x16x3 ; ##inlineasm##
      incbin "gfx/body_right_4x16x3.bin" ; ##inlineasm##
    .*body_right_4x16x3_sprites ; ##inlineasm##
      for n,0,3-1 ; ##inlineasm##
        equw (body_right_4x16x3+n*((4*16)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
    .tail_up_8x8x1 ; ##inlineasm##
      incbin "gfx/tail_up_8x8x1.bin" ; ##inlineasm##
    .*tail_up_8x8x1_sprites ; ##inlineasm##
      for n,0,1-1 ; ##inlineasm##
        equw (tail_up_8x8x1+n*((8*8)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .tail_down_8x8x1 ; ##inlineasm##
      incbin "gfx/tail_down_8x8x1.bin" ; ##inlineasm##
    .*tail_down_8x8x1_sprites ; ##inlineasm##
      for n,0,1-1 ; ##inlineasm##
        equw (tail_down_8x8x1+n*((8*8)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .tail_left_8x16x2 ; ##inlineasm##
      incbin "gfx/tail_left_8x16x2.bin" ; ##inlineasm##
    .*tail_left_8x16x2_sprites ; ##inlineasm##
      for n,0,2-1 ; ##inlineasm##
        equw (tail_left_8x16x2+n*((8*16)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .tail_right_8x16x2 ; ##inlineasm##
      incbin "gfx/tail_right_8x16x2.bin" ; ##inlineasm##
    .*tail_right_8x16x2_sprites ; ##inlineasm##
      for n,0,2-1 ; ##inlineasm##
        equw (tail_right_8x16x2+n*((8*16)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
    .corner_left_up_8x16x8 ; ##inlineasm##
      incbin "gfx/corner_left_up_8x16x8.bin" ; ##inlineasm##
    .*corner_left_up_8x16x8_sprites ; ##inlineasm##
      for n,0,8-1 ; ##inlineasm##
        equw (corner_left_up_8x16x8+n*((8*16)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .corner_left_down_8x16x8 ; ##inlineasm##
      incbin "gfx/corner_left_down_8x16x8.bin" ; ##inlineasm##
    .*corner_left_down_8x16x8_sprites ; ##inlineasm##
      for n,0,8-1 ; ##inlineasm##
        equw (corner_left_down_8x16x8+n*((8*16)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .corner_right_up_8x16x8 ; ##inlineasm##
      incbin "gfx/corner_right_up_8x16x8.bin" ; ##inlineasm##
    .*corner_right_up_8x16x8_sprites ; ##inlineasm##
      for n,0,8-1 ; ##inlineasm##
        equw (corner_right_up_8x16x8+n*((8*16)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
    .corner_right_down_8x16x8 ; ##inlineasm##
      incbin "gfx/corner_right_down_8x16x8.bin" ; ##inlineasm##
    .*corner_right_down_8x16x8_sprites ; ##inlineasm##
      for n,0,8-1 ; ##inlineasm##
        equw (corner_right_down_8x16x8+n*((8*16)/4)) ; ##inlineasm##
      next ;n ; ##inlineasm##
   ; ##inlineasm##
{ ; ##inlineasm##
    __P__=* ; ##inlineasm##
    org &900 ; ##inlineasm##
    .*python_trail ; 256 bytes of free space needed (in page &900) ; ##inlineasm##
    org __P__ ; ##inlineasm##
} ; ##inlineasm##
   ; ##inlineasm##
   ; ##inlineasm##
._exit_data
  rts
}
._end_of_data

._init
{
  jsr _sys_init
  jsr _txt_init
  jsr _gfx_init
  jsr _spr_init
  jsr _snd_init
   ; ##inlineasm##
    { ; ##inlineasm##
      lda ___sys_is_electron ; ##inlineasm##
      beq beeb ; ##inlineasm##
      lda #0: sta &242 ; &&&&Elk only: disable key scanning for slight speed up; does seem to give some problems when calling OSCLI for instance (?) ; ##inlineasm##
    .beeb ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
  lda #&05 ; lsb of 5
  jsr _mode
  txa
  pha ; save current frameptr X, because function 'cursor' uses its own frameptr X
  lda #&00 ; lsb of 0
  jsr _cursor
  jsr _def_chars
  pla
  tax ; restore previous frameptr X
  lda #&01 ; lsb of 1
  sta _music_toggle
  lda #&00 ; lsb of 0
  sta _hiscore ; lsb
  sta _hiscore+1 ; msb
._exit_init
  rts
}
._end_of_init

._print_font_str_at
{
  ; space for parameters: 4 byte(s)
  _print_font_str_at_prm_x=&0103 ; 8bit function parameter 'x' of type 'byte'
  _print_font_str_at_prm_y=&0104 ; 8bit function parameter 'y' of type 'byte'
  _print_font_str_at_prm_s=&0105 ; 16bit function parameter 's' of type 'word'
  ; space for local variables: 1 byte(s)
  _print_font_str_at_var_c=&0100 ; 8bit local variable 'c' of type 'byte'
  tsx ; set new frame pointer X
  pha ; claim space (1 byte(s)) for local variables on stack
  ldal _print_font_str_at_prm_s
  sta _e_t0
  ldal _print_font_str_at_prm_s+1
  sta _e_t1
  ldy #&00
  lda (_e_t0),y ; get byte from address
  stal _print_font_str_at_var_c
{
.while_loop
  ldal _print_font_str_at_var_c
  bne do_while
  jmp end_while: .do_while
  ldal _print_font_str_at_var_c
  cmp #&20 ; lsb of 32
  {: bne if_clause
  jmp else_clause: .if_clause
  ldal _print_font_str_at_var_c
  sec
  sbc #&40 ; lsb of 64
  asl a
  stal _print_font_str_at_var_c
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x8_mode_5' uses its own frameptr X
  lda #lo(letters_symbols_8x8x32_sprites)
  clc
  adcl _print_font_str_at_var_c
  tay
  lda #hi(letters_symbols_8x8x32_sprites)
  adc #&00 ; virtual msb of 2nd operand
  pha ; leave 16bit result on stack, msb first
  tya
  pha ; lsb
  ldal _print_font_str_at_prm_y
  pha ; lsb
  ldal _print_font_str_at_prm_x
  pha ; lsb
  jsr ___spr_spriteplot8x8_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
 .else_clause
.end_if: }
  ldal _print_font_str_at_prm_x
  clc
  adc #&08 ; lsb of 8
  stal _print_font_str_at_prm_x
  incl _print_font_str_at_prm_s ; lsb
  bne *+5 ; do lsb only, skip msb
  incl _print_font_str_at_prm_s+1 ; msb
  ldal _print_font_str_at_prm_s
  sta _e_t0
  ldal _print_font_str_at_prm_s+1
  sta _e_t1
  ldy #&00
  lda (_e_t0),y ; get byte from address
  stal _print_font_str_at_var_c
  jmp while_loop: .end_while: }
._exit_print_font_str_at
  txs ; release stack space (1 byte(s)) for local variables
  rts
}
._end_of_print_font_str_at

._init_game
{
  lda #&01 ; lsb of 1
  sta _level
  lda #&05 ; lsb of 5
  sta _lives
  lda #&64 ; lsb of 100
  sta _start_time
  lda #&00 ; lsb of 0
  sta _score ; lsb
  sta _score+1 ; msb
._exit_init_game
  rts
}
._end_of_init_game

._init_level
{
  lda #&00 ; lsb of 0
  sta _n_diamonds
  sta _grow
  sta _stuck
  lda _start_time
  sta _time
  lda #&32 ; lsb of 50
  sta _time_counter_reload
  sta _time_counter
  lda #&00 ; lsb of 0
  sta _time_needs_update
  sta _time_enabled
  sta _tune_enabled
  lda #lo(tune_data)
  sta _tune_index ; lsb
  lda #hi(tune_data)
  sta _tune_index+1 ; msb
  lda #&0a ; lsb of 10
  sta _tune_counter_reload
  sta _tune_counter
  lda #&04 ; lsb of 4
  sta _tune_note_len
   ; ##inlineasm##
      txa: pha ; ##inlineasm##
      lda #21 ; ##inlineasm##
      ldx #0 ; ##inlineasm##
      jsr &fff4 ; OSBYTE: *FX21,0 flush keyboard buffer // this doesn't help with emulators which buffer key presses at host level! ; ##inlineasm##
      pla: tax ; ##inlineasm##
   ; ##inlineasm##
._exit_init_level
  rts
}
._end_of_init_level

._init_and_draw_python
{
  ; space for parameters: 3 byte(s)
  _init_and_draw_python_prm_x=&0103 ; 8bit function parameter 'x' of type 'byte'
  _init_and_draw_python_prm_y=&0104 ; 8bit function parameter 'y' of type 'byte'
  _init_and_draw_python_prm_len=&0105 ; 8bit function parameter 'len' of type 'byte'
  tsx ; set new frame pointer X
  lda #&00 ; lsb of 0
  sta _tailtrail
  ldal _init_and_draw_python_prm_len
  asl a
  sta _headtrail
  lda #&80 ; lsb of 128
  sta _state
  ldal _init_and_draw_python_prm_x
  sta _headx
  ldal _init_and_draw_python_prm_y
  sta _heady
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot12x16_mode_5' uses its own frameptr X
  lda #hi(head_right_12x16x2_sprites)
  pha
  lda #lo(head_right_12x16x2_sprites)
  pha
  lda _heady
  pha ; lsb
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot12x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
{
.while_loop
  ldal _init_and_draw_python_prm_len
  bne do_while
  jmp end_while: .do_while
  ldal _init_and_draw_python_prm_x
  sec
  sbc #&04 ; lsb of 4
  stal _init_and_draw_python_prm_x
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot4x16_mode_5' uses its own frameptr X
  lda #lo(body_right_4x16x3_sprites)
  clc
  adc #&02 ; lsb of 2
  tay
  lda #hi(body_right_4x16x3_sprites)
  adc #&00 ; virtual msb of 2nd operand
  pha ; leave 16bit result on stack, msb first
  tya
  pha ; lsb
  lda _heady
  pha ; lsb
  ldal _init_and_draw_python_prm_x
  pha ; lsb
  jsr ___spr_spriteplot4x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  decl _init_and_draw_python_prm_len
  jmp while_loop: .end_while: }
{
.while_loop
  ldal _init_and_draw_python_prm_len
  cmp _headtrail
  bcc do_while
  jmp end_while: .do_while
{
  lda #&82 ; lsb of 130
  pha
  lda #lo(python_trail)
  clc
  adcl _init_and_draw_python_prm_len
  sta _e_t0
  lda #hi(python_trail)
  adc #&00 ; virtual msb of 2nd operand
  sta _e_t1
  ldy #&00
  pla ; get lsb of value
  sta (_e_t0),y ; and store it
}
  incl _init_and_draw_python_prm_len
  jmp while_loop: .end_while: }
  ldal _init_and_draw_python_prm_x
  sec
  sbc #&04 ; lsb of 4
  sta _tailx
  lda _heady
  sta _taily
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  lda #hi(tail_right_8x16x2_sprites)
  pha
  lda #lo(tail_right_8x16x2_sprites)
  pha
  lda _taily
  pha ; lsb
  lda _tailx
  pha ; lsb
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  lda #&00 ; lsb of 0
  sta _headcornertype
  sta _headcornerstate
  sta _tailcornerstate
._exit_init_and_draw_python
  rts
}
._end_of_init_and_draw_python

._sync_head
{
  lda _heady
  cmp #&6c ; lsb of 108
  {: bcc if_clause
  jmp else_clause: .if_clause
  jsr _wait_rtc
  jmp end_if: .else_clause
  jsr _wait_vsync
.end_if: }
._exit_sync_head
  rts
}
._end_of_sync_head

._sync_tail
{
  lda _heady
  ldy #&00: { ; assume false
  cmp #&6c ; lsb of 108
  bcc false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  pha ; push resulting boolean (0=false, -1=true)
  lda _taily
  ldy #&00: { ; assume false
  cmp #&6c ; lsb of 108
  bcs false: .true
  dey: .false: } ; Y=-1 (true)
  sty _e_t0
  pla ; 1st operand (8bit)
  and _e_t0
  {: bne if_clause
  jmp else_clause: .if_clause
  jsr _wait_rtc
  jmp end_if: .else_clause
  lda _heady
  ldy #&00: { ; assume false
  cmp #&6c ; lsb of 108
  bcs false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  pha ; push resulting boolean (0=false, -1=true)
  lda _taily
  ldy #&00: { ; assume false
  cmp #&6c ; lsb of 108
  bcc false: .true
  dey: .false: } ; Y=-1 (true)
  sty _e_t0
  pla ; 1st operand (8bit)
  and _e_t0
  {: bne if_clause
  jmp else_clause: .if_clause
  jsr _wait_vsync
 .else_clause
.end_if: }
.end_if: }
._exit_sync_tail
  rts
}
._end_of_sync_tail

._draw_head_corner
{
  ; space for parameters: 3 byte(s)
  _draw_head_corner_prm_corner_spr=&0103 ; 16bit function parameter 'corner_spr' of type 'word'
  _draw_head_corner_prm_offs=&0105 ; 8bit function parameter 'offs' of type 'byte'
  tsx ; set new frame pointer X
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  ldal _draw_head_corner_prm_corner_spr
  clc
  adcl _draw_head_corner_prm_offs
  tay
  ldal _draw_head_corner_prm_corner_spr+1
  adc #&00 ; virtual msb of 2nd operand
  pha ; leave 16bit result on stack, msb first
  tya
  pha ; lsb
  lda _headcornery
  pha ; lsb
  lda _headcornerx
  pha ; lsb
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
._exit_draw_head_corner
  rts
}
._end_of_draw_head_corner

._move_python_UD
{
  ; space for parameters: 17 byte(s)
  _move_python_UD_prm_dir=&0103 ; 8bit function parameter 'dir' of type 'byte'
  _move_python_UD_prm_offs1=&0104 ; 8bit function parameter 'offs1' of type 'int8'
  _move_python_UD_prm_offs2=&0105 ; 8bit function parameter 'offs2' of type 'int8'
  _move_python_UD_prm_ct1=&0106 ; 8bit function parameter 'ct1' of type 'byte'
  _move_python_UD_prm_ct2=&0107 ; 8bit function parameter 'ct2' of type 'byte'
  _move_python_UD_prm_head_spr=&0108 ; 16bit function parameter 'head_spr' of type 'word'
  _move_python_UD_prm_ct1_head_spr=&010a ; 16bit function parameter 'ct1_head_spr' of type 'word'
  _move_python_UD_prm_ct1_corner_spr=&010c ; 16bit function parameter 'ct1_corner_spr' of type 'word'
  _move_python_UD_prm_ct2_head_spr=&010e ; 16bit function parameter 'ct2_head_spr' of type 'word'
  _move_python_UD_prm_ct2_corner_spr=&0110 ; 16bit function parameter 'ct2_corner_spr' of type 'word'
  _move_python_UD_prm_body_spr=&0112 ; 16bit function parameter 'body_spr' of type 'word'
  ; space for local variables: 2 byte(s)
  _move_python_UD_var_addr=&00ff ; 16bit local variable 'addr' of type 'word'
  tsx ; set new frame pointer X
  pha
  pha ; claim space (2 byte(s)) for local variables on stack
  lda #lo(python_trail)
  clc
  adc _headtrail
  stal _move_python_UD_var_addr ; lsb
  lda #hi(python_trail)
  adc #&00 ; virtual msb of 2nd operand
  stal _move_python_UD_var_addr+1 ; msb
  jsr _sync_head
  lda _headcornertype
  cmpl _move_python_UD_prm_ct1
  {: beq if_clause
  jmp else_clause: .if_clause
  lda _headcornerstate
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot12x16_mode_5' uses its own frameptr X
  ldal _move_python_UD_prm_ct1_head_spr+1
  pha ; msb
  ldal _move_python_UD_prm_ct1_head_spr
  pha ; lsb
  lda _heady
  pha ; lsb
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot12x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_head_corner' uses its own frameptr X
  lda #&00 ; lsb of 0
  pha
  ldal _move_python_UD_prm_ct1_corner_spr+1
  pha ; msb
  ldal _move_python_UD_prm_ct1_corner_spr
  pha ; lsb
  jsr _draw_head_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  ldal _move_python_UD_prm_head_spr+1
  pha ; msb
  ldal _move_python_UD_prm_head_spr
  pha ; lsb
  lda _heady
  pha ; lsb
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_head_corner' uses its own frameptr X
  lda _headcornerstate
  sec
  sbc #&02 ; lsb of 2
  pha ; leave 8bit result on stack
  ldal _move_python_UD_prm_ct1_corner_spr+1
  pha ; msb
  ldal _move_python_UD_prm_ct1_corner_spr
  pha ; lsb
  jsr _draw_head_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_head_corner' uses its own frameptr X
  lda _headcornerstate
  pha ; lsb
  ldal _move_python_UD_prm_ct1_corner_spr+1
  pha ; msb
  ldal _move_python_UD_prm_ct1_corner_spr
  pha ; lsb
  jsr _draw_head_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
.end_if: }
{
  ldal _move_python_UD_var_addr
  sta _e_t0
  ldal _move_python_UD_var_addr+1
  sta _e_t1
  ldy #&00
  ldal _move_python_UD_prm_ct1
  sta (_e_t0),y ; and store it
}
  jmp end_if: .else_clause
  lda _headcornertype
  cmpl _move_python_UD_prm_ct2
  {: beq if_clause
  jmp else_clause: .if_clause
  lda _headcornerstate
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot12x16_mode_5' uses its own frameptr X
  ldal _move_python_UD_prm_ct2_head_spr+1
  pha ; msb
  ldal _move_python_UD_prm_ct2_head_spr
  pha ; lsb
  lda _heady
  pha ; lsb
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot12x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_head_corner' uses its own frameptr X
  lda #&00 ; lsb of 0
  pha
  ldal _move_python_UD_prm_ct2_corner_spr+1
  pha ; msb
  ldal _move_python_UD_prm_ct2_corner_spr
  pha ; lsb
  jsr _draw_head_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  ldal _move_python_UD_prm_head_spr+1
  pha ; msb
  ldal _move_python_UD_prm_head_spr
  pha ; lsb
  lda _heady
  pha ; lsb
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_head_corner' uses its own frameptr X
  lda _headcornerstate
  sec
  sbc #&02 ; lsb of 2
  pha ; leave 8bit result on stack
  ldal _move_python_UD_prm_ct2_corner_spr+1
  pha ; msb
  ldal _move_python_UD_prm_ct2_corner_spr
  pha ; lsb
  jsr _draw_head_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_head_corner' uses its own frameptr X
  lda _headcornerstate
  pha ; lsb
  ldal _move_python_UD_prm_ct2_corner_spr+1
  pha ; msb
  ldal _move_python_UD_prm_ct2_corner_spr
  pha ; lsb
  jsr _draw_head_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
.end_if: }
{
  ldal _move_python_UD_var_addr
  sta _e_t0
  ldal _move_python_UD_var_addr+1
  sta _e_t1
  ldy #&00
  ldal _move_python_UD_prm_ct2
  sta (_e_t0),y ; and store it
}
  jmp end_if: .else_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  ldal _move_python_UD_prm_head_spr+1
  pha ; msb
  ldal _move_python_UD_prm_head_spr
  pha ; lsb
  lda _heady
  pha ; lsb
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  lda _heady
  and #&07 ; lsb of 7
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x8_mode_5' uses its own frameptr X
  ldal _move_python_UD_prm_body_spr+1
  pha ; msb
  ldal _move_python_UD_prm_body_spr
  pha ; lsb
  lda _heady
  clc
  adcl _move_python_UD_prm_offs1
  pha ; leave 8bit result on stack
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot8x8_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
 .else_clause
.end_if: }
{
  ldal _move_python_UD_var_addr
  sta _e_t0
  ldal _move_python_UD_var_addr+1
  sta _e_t1
  ldy #&00
  ldal _move_python_UD_prm_dir
  sta (_e_t0),y ; and store it
}
.end_if: }
.end_if: }
  ldal _move_python_UD_prm_dir
  cmp #&84 ; lsb of 132
  {: beq if_clause
  jmp else_clause: .if_clause
  lda _heady
  clc
  adc #&04 ; lsb of 4
  sta _heady
  jmp end_if: .else_clause
  lda _heady
  sec
  sbc #&04 ; lsb of 4
  sta _heady
.end_if: }
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  ldal _move_python_UD_prm_head_spr+1
  pha ; msb
  ldal _move_python_UD_prm_head_spr
  pha ; lsb
  lda _heady
  pha ; lsb
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  lda _headcornertype
  {: beq if_clause
  jmp else_clause: .if_clause
  lda _heady
  and #&07 ; lsb of 7
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x8_mode_5' uses its own frameptr X
  ldal _move_python_UD_prm_body_spr+1
  pha ; msb
  ldal _move_python_UD_prm_body_spr
  pha ; lsb
  lda _heady
  clc
  adcl _move_python_UD_prm_offs1
  pha ; leave 8bit result on stack
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot8x8_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x8_mode_5' uses its own frameptr X
  ldal _move_python_UD_prm_body_spr
  clc
  adc #&02 ; lsb of 2
  tay
  ldal _move_python_UD_prm_body_spr+1
  adc #&00 ; virtual msb of 2nd operand
  pha ; leave 16bit result on stack, msb first
  tya
  pha ; lsb
  lda _heady
  clc
  adcl _move_python_UD_prm_offs2
  pha ; leave 8bit result on stack
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot8x8_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
.end_if: }
  jmp end_if: .else_clause
  lda _headcornerstate
  clc
  adc #&02 ; lsb of 2
  sta _headcornerstate
  cmp #&08 ; lsb of 8
  {: beq if_clause
  jmp else_clause: .if_clause
  lda #&00 ; lsb of 0
  sta _headcornertype
 .else_clause
.end_if: }
.end_if: }
  inc _headtrail
  txa
  pha ; save current frameptr X, because function 'update_tail' uses its own frameptr X
  lda #&01 ; lsb of 1
  jsr _update_tail
  pla
  tax ; restore previous frameptr X
._exit_move_python_UD
  txs ; release stack space (2 byte(s)) for local variables
  rts
}
._end_of_move_python_UD

._move_python_LR
{
  ; space for parameters: 17 byte(s)
  _move_python_LR_prm_dir=&0103 ; 8bit function parameter 'dir' of type 'byte'
  _move_python_LR_prm_offs1=&0104 ; 8bit function parameter 'offs1' of type 'int8'
  _move_python_LR_prm_offs2=&0105 ; 8bit function parameter 'offs2' of type 'int8'
  _move_python_LR_prm_ct1=&0106 ; 8bit function parameter 'ct1' of type 'byte'
  _move_python_LR_prm_ct2=&0107 ; 8bit function parameter 'ct2' of type 'byte'
  _move_python_LR_prm_head_spr=&0108 ; 16bit function parameter 'head_spr' of type 'word'
  _move_python_LR_prm_ct1_head_spr=&010a ; 16bit function parameter 'ct1_head_spr' of type 'word'
  _move_python_LR_prm_ct1_corner_spr=&010c ; 16bit function parameter 'ct1_corner_spr' of type 'word'
  _move_python_LR_prm_ct2_head_spr=&010e ; 16bit function parameter 'ct2_head_spr' of type 'word'
  _move_python_LR_prm_ct2_corner_spr=&0110 ; 16bit function parameter 'ct2_corner_spr' of type 'word'
  _move_python_LR_prm_body_spr=&0112 ; 16bit function parameter 'body_spr' of type 'word'
  ; space for local variables: 2 byte(s)
  _move_python_LR_var_addr=&00ff ; 16bit local variable 'addr' of type 'word'
  tsx ; set new frame pointer X
  pha
  pha ; claim space (2 byte(s)) for local variables on stack
  lda #lo(python_trail)
  clc
  adc _headtrail
  stal _move_python_LR_var_addr ; lsb
  lda #hi(python_trail)
  adc #&00 ; virtual msb of 2nd operand
  stal _move_python_LR_var_addr+1 ; msb
  jsr _sync_head
  lda _headcornertype
  cmpl _move_python_LR_prm_ct1
  {: beq if_clause
  jmp else_clause: .if_clause
  lda _headcornerstate
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  ldal _move_python_LR_prm_ct1_head_spr+1
  pha ; msb
  ldal _move_python_LR_prm_ct1_head_spr
  pha ; lsb
  lda _heady
  pha ; lsb
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_head_corner' uses its own frameptr X
  lda #&00 ; lsb of 0
  pha
  ldal _move_python_LR_prm_ct1_corner_spr+1
  pha ; msb
  ldal _move_python_LR_prm_ct1_corner_spr
  pha ; lsb
  jsr _draw_head_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot12x16_mode_5' uses its own frameptr X
  ldal _move_python_LR_prm_head_spr+1
  pha ; msb
  ldal _move_python_LR_prm_head_spr
  pha ; lsb
  lda _heady
  pha ; lsb
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot12x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_head_corner' uses its own frameptr X
  lda _headcornerstate
  sec
  sbc #&02 ; lsb of 2
  pha ; leave 8bit result on stack
  ldal _move_python_LR_prm_ct1_corner_spr+1
  pha ; msb
  ldal _move_python_LR_prm_ct1_corner_spr
  pha ; lsb
  jsr _draw_head_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_head_corner' uses its own frameptr X
  lda _headcornerstate
  pha ; lsb
  ldal _move_python_LR_prm_ct1_corner_spr+1
  pha ; msb
  ldal _move_python_LR_prm_ct1_corner_spr
  pha ; lsb
  jsr _draw_head_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
.end_if: }
{
  ldal _move_python_LR_var_addr
  sta _e_t0
  ldal _move_python_LR_var_addr+1
  sta _e_t1
  ldy #&00
  ldal _move_python_LR_prm_ct1
  sta (_e_t0),y ; and store it
}
  jmp end_if: .else_clause
  lda _headcornertype
  cmpl _move_python_LR_prm_ct2
  {: beq if_clause
  jmp else_clause: .if_clause
  lda _headcornerstate
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  ldal _move_python_LR_prm_ct2_head_spr+1
  pha ; msb
  ldal _move_python_LR_prm_ct2_head_spr
  pha ; lsb
  lda _heady
  pha ; lsb
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_head_corner' uses its own frameptr X
  lda #&00 ; lsb of 0
  pha
  ldal _move_python_LR_prm_ct2_corner_spr+1
  pha ; msb
  ldal _move_python_LR_prm_ct2_corner_spr
  pha ; lsb
  jsr _draw_head_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot12x16_mode_5' uses its own frameptr X
  ldal _move_python_LR_prm_head_spr+1
  pha ; msb
  ldal _move_python_LR_prm_head_spr
  pha ; lsb
  lda _heady
  pha ; lsb
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot12x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_head_corner' uses its own frameptr X
  lda _headcornerstate
  sec
  sbc #&02 ; lsb of 2
  pha ; leave 8bit result on stack
  ldal _move_python_LR_prm_ct2_corner_spr+1
  pha ; msb
  ldal _move_python_LR_prm_ct2_corner_spr
  pha ; lsb
  jsr _draw_head_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_head_corner' uses its own frameptr X
  lda _headcornerstate
  pha ; lsb
  ldal _move_python_LR_prm_ct2_corner_spr+1
  pha ; msb
  ldal _move_python_LR_prm_ct2_corner_spr
  pha ; lsb
  jsr _draw_head_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
.end_if: }
{
  ldal _move_python_LR_var_addr
  sta _e_t0
  ldal _move_python_LR_var_addr+1
  sta _e_t1
  ldy #&00
  ldal _move_python_LR_prm_ct2
  sta (_e_t0),y ; and store it
}
  jmp end_if: .else_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot12x16_mode_5' uses its own frameptr X
  ldal _move_python_LR_prm_head_spr+1
  pha ; msb
  ldal _move_python_LR_prm_head_spr
  pha ; lsb
  lda _heady
  pha ; lsb
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot12x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  lda _headx
  and #&03 ; lsb of 3
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot4x16_mode_5' uses its own frameptr X
  ldal _move_python_LR_prm_body_spr+1
  pha ; msb
  ldal _move_python_LR_prm_body_spr
  pha ; lsb
  lda _heady
  pha ; lsb
  lda _headx
  clc
  adcl _move_python_LR_prm_offs1
  pha ; leave 8bit result on stack
  jsr ___spr_spriteplot4x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
 .else_clause
.end_if: }
{
  ldal _move_python_LR_var_addr
  sta _e_t0
  ldal _move_python_LR_var_addr+1
  sta _e_t1
  ldy #&00
  ldal _move_python_LR_prm_dir
  sta (_e_t0),y ; and store it
}
.end_if: }
.end_if: }
  ldal _move_python_LR_prm_dir
  cmp #&82 ; lsb of 130
  {: beq if_clause
  jmp else_clause: .if_clause
  lda _headx
  clc
  adc #&02 ; lsb of 2
  sta _headx
  jmp end_if: .else_clause
  lda _headx
  sec
  sbc #&02 ; lsb of 2
  sta _headx
.end_if: }
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot12x16_mode_5' uses its own frameptr X
  ldal _move_python_LR_prm_head_spr+1
  pha ; msb
  ldal _move_python_LR_prm_head_spr
  pha ; lsb
  lda _heady
  pha ; lsb
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot12x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  lda _headcornertype
  {: beq if_clause
  jmp else_clause: .if_clause
  lda _headx
  and #&03 ; lsb of 3
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot4x16_mode_5' uses its own frameptr X
  ldal _move_python_LR_prm_body_spr+1
  pha ; msb
  ldal _move_python_LR_prm_body_spr
  pha ; lsb
  lda _heady
  pha ; lsb
  lda _headx
  clc
  adcl _move_python_LR_prm_offs1
  pha ; leave 8bit result on stack
  jsr ___spr_spriteplot4x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot4x16_mode_5' uses its own frameptr X
  ldal _move_python_LR_prm_body_spr
  clc
  adc #&02 ; lsb of 2
  tay
  ldal _move_python_LR_prm_body_spr+1
  adc #&00 ; virtual msb of 2nd operand
  pha ; leave 16bit result on stack, msb first
  tya
  pha ; lsb
  lda _heady
  pha ; lsb
  lda _headx
  clc
  adcl _move_python_LR_prm_offs2
  pha ; leave 8bit result on stack
  jsr ___spr_spriteplot4x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
.end_if: }
  jmp end_if: .else_clause
  lda _headcornerstate
  clc
  adc #&02 ; lsb of 2
  sta _headcornerstate
  cmp #&08 ; lsb of 8
  {: beq if_clause
  jmp else_clause: .if_clause
  lda #&00 ; lsb of 0
  sta _headcornertype
 .else_clause
.end_if: }
.end_if: }
  inc _headtrail
  txa
  pha ; save current frameptr X, because function 'update_tail' uses its own frameptr X
  lda #&01 ; lsb of 1
  jsr _update_tail
  pla
  tax ; restore previous frameptr X
._exit_move_python_LR
  txs ; release stack space (2 byte(s)) for local variables
  rts
}
._end_of_move_python_LR

._python_right
{
  txa
  pha ; save current frameptr X, because function 'move_python_LR' uses its own frameptr X
  lda #hi(body_right_4x16x3_sprites)
  pha
  lda #lo(body_right_4x16x3_sprites)
  pha
  lda #hi(corner_down_right_8x16x8_sprites)
  pha
  lda #lo(corner_down_right_8x16x8_sprites)
  pha
  lda #hi(head_down_8x16x1_sprites)
  pha
  lda #lo(head_down_8x16x1_sprites)
  pha
  lda #hi(corner_up_right_8x16x8_sprites)
  pha
  lda #lo(corner_up_right_8x16x8_sprites)
  pha
  lda #hi(head_up_8x16x1_sprites)
  pha
  lda #lo(head_up_8x16x1_sprites)
  pha
  lda #hi(head_right_12x16x2_sprites)
  pha
  lda #lo(head_right_12x16x2_sprites)
  pha
  lda #&08 ; lsb of 8
  pha
  lda #&06 ; lsb of 6
  pha
  lda #&fc ; lsb of -4
  pha
  lda #&fe ; lsb of -2
  pha
  lda #&82 ; lsb of 130
  pha
  jsr _move_python_LR
  tsx
  txa
  clc
  adc #&11
  tax
  txs
  pla
  tax ; restore previous frameptr X
  lda #&01 ; lsb of 1
  sta _moved
._exit_python_right
  rts
}
._end_of_python_right

._python_left
{
  txa
  pha ; save current frameptr X, because function 'move_python_LR' uses its own frameptr X
  lda #hi(body_left_4x16x3_sprites)
  pha
  lda #lo(body_left_4x16x3_sprites)
  pha
  lda #hi(corner_down_left_8x16x8_sprites)
  pha
  lda #lo(corner_down_left_8x16x8_sprites)
  pha
  lda #hi(head_down_8x16x1_sprites)
  pha
  lda #lo(head_down_8x16x1_sprites)
  pha
  lda #hi(corner_up_left_8x16x8_sprites)
  pha
  lda #lo(corner_up_left_8x16x8_sprites)
  pha
  lda #hi(head_up_8x16x1_sprites)
  pha
  lda #lo(head_up_8x16x1_sprites)
  pha
  lda #hi(head_left_12x16x2_sprites)
  pha
  lda #lo(head_left_12x16x2_sprites)
  pha
  lda #&07 ; lsb of 7
  pha
  lda #&05 ; lsb of 5
  pha
  lda #&08 ; lsb of 8
  pha
  lda #&06 ; lsb of 6
  pha
  lda #&81 ; lsb of 129
  pha
  jsr _move_python_LR
  tsx
  txa
  clc
  adc #&11
  tax
  txs
  pla
  tax ; restore previous frameptr X
  lda #&01 ; lsb of 1
  sta _moved
._exit_python_left
  rts
}
._end_of_python_left

._python_up
{
  txa
  pha ; save current frameptr X, because function 'move_python_UD' uses its own frameptr X
  lda #hi(body_up_8x8x3_sprites)
  pha
  lda #lo(body_up_8x8x3_sprites)
  pha
  lda #hi(corner_left_up_8x16x8_sprites)
  pha
  lda #lo(corner_left_up_8x16x8_sprites)
  pha
  lda #hi(head_left_12x16x2_sprites)
  pha
  lda #lo(head_left_12x16x2_sprites)
  pha
  lda #hi(corner_right_up_8x16x8_sprites)
  pha
  lda #lo(corner_right_up_8x16x8_sprites)
  pha
  lda #hi(head_right_12x16x2_sprites)
  pha
  lda #lo(head_right_12x16x2_sprites)
  pha
  lda #hi(head_up_8x16x1_sprites)
  pha
  lda #lo(head_up_8x16x1_sprites)
  pha
  lda #&03 ; lsb of 3
  pha
  lda #&01 ; lsb of 1
  pha
  lda #&10 ; lsb of 16
  pha
  lda #&0c ; lsb of 12
  pha
  lda #&83 ; lsb of 131
  pha
  jsr _move_python_UD
  tsx
  txa
  clc
  adc #&11
  tax
  txs
  pla
  tax ; restore previous frameptr X
  lda #&01 ; lsb of 1
  sta _moved
._exit_python_up
  rts
}
._end_of_python_up

._python_down
{
  txa
  pha ; save current frameptr X, because function 'move_python_UD' uses its own frameptr X
  lda #hi(body_down_8x8x3_sprites)
  pha
  lda #lo(body_down_8x8x3_sprites)
  pha
  lda #hi(corner_left_down_8x16x8_sprites)
  pha
  lda #lo(corner_left_down_8x16x8_sprites)
  pha
  lda #hi(head_left_12x16x2_sprites)
  pha
  lda #lo(head_left_12x16x2_sprites)
  pha
  lda #hi(corner_right_down_8x16x8_sprites)
  pha
  lda #lo(corner_right_down_8x16x8_sprites)
  pha
  lda #hi(head_right_12x16x2_sprites)
  pha
  lda #lo(head_right_12x16x2_sprites)
  pha
  lda #hi(head_down_8x16x1_sprites)
  pha
  lda #lo(head_down_8x16x1_sprites)
  pha
  lda #&04 ; lsb of 4
  pha
  lda #&02 ; lsb of 2
  pha
  lda #&f8 ; lsb of -8
  pha
  lda #&fc ; lsb of -4
  pha
  lda #&84 ; lsb of 132
  pha
  jsr _move_python_UD
  tsx
  txa
  clc
  adc #&11
  tax
  txs
  pla
  tax ; restore previous frameptr X
  lda #&01 ; lsb of 1
  sta _moved
._exit_python_down
  rts
}
._end_of_python_down

._move_tail_LR
{
  ; space for parameters: 7 byte(s)
  _move_tail_LR_prm_dir=&0103 ; 8bit function parameter 'dir' of type 'byte'
  _move_tail_LR_prm_offs1=&0104 ; 8bit function parameter 'offs1' of type 'int8'
  _move_tail_LR_prm_offs2=&0105 ; 8bit function parameter 'offs2' of type 'int8'
  _move_tail_LR_prm_body_spr=&0106 ; 16bit function parameter 'body_spr' of type 'word'
  _move_tail_LR_prm_tail_spr=&0108 ; 16bit function parameter 'tail_spr' of type 'word'
  tsx ; set new frame pointer X
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  ldal _move_tail_LR_prm_tail_spr+1
  pha ; msb
  ldal _move_tail_LR_prm_tail_spr
  pha ; lsb
  lda _taily
  pha ; lsb
  lda _tailx
  pha ; lsb
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  lda _tailx
  and #&03 ; lsb of 3
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot4x16_mode_5' uses its own frameptr X
  ldal _move_tail_LR_prm_body_spr
  clc
  adc #&04 ; lsb of 4
  tay
  ldal _move_tail_LR_prm_body_spr+1
  adc #&00 ; virtual msb of 2nd operand
  pha ; leave 16bit result on stack, msb first
  tya
  pha ; lsb
  lda _taily
  pha ; lsb
  lda _tailx
  clc
  adcl _move_tail_LR_prm_offs1
  pha ; leave 8bit result on stack
  jsr ___spr_spriteplot4x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot4x16_mode_5' uses its own frameptr X
  ldal _move_tail_LR_prm_body_spr
  clc
  adc #&02 ; lsb of 2
  tay
  ldal _move_tail_LR_prm_body_spr+1
  adc #&00 ; virtual msb of 2nd operand
  pha ; leave 16bit result on stack, msb first
  tya
  pha ; lsb
  lda _taily
  pha ; lsb
  lda _tailx
  clc
  adcl _move_tail_LR_prm_offs2
  pha ; leave 8bit result on stack
  jsr ___spr_spriteplot4x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
.end_if: }
  ldal _move_tail_LR_prm_dir
  cmp #&82 ; lsb of 130
  {: beq if_clause
  jmp else_clause: .if_clause
  lda _tailx
  clc
  adc #&02 ; lsb of 2
  sta _tailx
  jmp end_if: .else_clause
  lda _tailx
  sec
  sbc #&02 ; lsb of 2
  sta _tailx
.end_if: }
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  ldal _move_tail_LR_prm_tail_spr+1
  pha ; msb
  ldal _move_tail_LR_prm_tail_spr
  pha ; lsb
  lda _taily
  pha ; lsb
  lda _tailx
  pha ; lsb
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  lda _tailx
  and #&03 ; lsb of 3
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot4x16_mode_5' uses its own frameptr X
  ldal _move_tail_LR_prm_body_spr
  clc
  adc #&04 ; lsb of 4
  tay
  ldal _move_tail_LR_prm_body_spr+1
  adc #&00 ; virtual msb of 2nd operand
  pha ; leave 16bit result on stack, msb first
  tya
  pha ; lsb
  lda _taily
  pha ; lsb
  lda _tailx
  clc
  adcl _move_tail_LR_prm_offs1
  pha ; leave 8bit result on stack
  jsr ___spr_spriteplot4x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
 .else_clause
.end_if: }
  lda #&00 ; lsb of 0
  sta _tailcornerstate
._exit_move_tail_LR
  rts
}
._end_of_move_tail_LR

._move_tail_UD
{
  ; space for parameters: 7 byte(s)
  _move_tail_UD_prm_dir=&0103 ; 8bit function parameter 'dir' of type 'byte'
  _move_tail_UD_prm_offs1=&0104 ; 8bit function parameter 'offs1' of type 'int8'
  _move_tail_UD_prm_offs2=&0105 ; 8bit function parameter 'offs2' of type 'int8'
  _move_tail_UD_prm_body_spr=&0106 ; 16bit function parameter 'body_spr' of type 'word'
  _move_tail_UD_prm_tail_spr=&0108 ; 16bit function parameter 'tail_spr' of type 'word'
  tsx ; set new frame pointer X
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x8_mode_5' uses its own frameptr X
  ldal _move_tail_UD_prm_tail_spr+1
  pha ; msb
  ldal _move_tail_UD_prm_tail_spr
  pha ; lsb
  lda _taily
  pha ; lsb
  lda _tailx
  pha ; lsb
  jsr ___spr_spriteplot8x8_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  lda _taily
  and #&07 ; lsb of 7
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x8_mode_5' uses its own frameptr X
  ldal _move_tail_UD_prm_body_spr
  clc
  adc #&04 ; lsb of 4
  tay
  ldal _move_tail_UD_prm_body_spr+1
  adc #&00 ; virtual msb of 2nd operand
  pha ; leave 16bit result on stack, msb first
  tya
  pha ; lsb
  lda _taily
  clc
  adcl _move_tail_UD_prm_offs1
  pha ; leave 8bit result on stack
  lda _tailx
  pha ; lsb
  jsr ___spr_spriteplot8x8_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x8_mode_5' uses its own frameptr X
  ldal _move_tail_UD_prm_body_spr
  clc
  adc #&02 ; lsb of 2
  tay
  ldal _move_tail_UD_prm_body_spr+1
  adc #&00 ; virtual msb of 2nd operand
  pha ; leave 16bit result on stack, msb first
  tya
  pha ; lsb
  lda _taily
  clc
  adcl _move_tail_UD_prm_offs2
  pha ; leave 8bit result on stack
  lda _tailx
  pha ; lsb
  jsr ___spr_spriteplot8x8_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
.end_if: }
  ldal _move_tail_UD_prm_dir
  cmp #&83 ; lsb of 131
  {: beq if_clause
  jmp else_clause: .if_clause
  lda _taily
  sec
  sbc #&04 ; lsb of 4
  sta _taily
  jmp end_if: .else_clause
  lda _taily
  clc
  adc #&04 ; lsb of 4
  sta _taily
.end_if: }
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x8_mode_5' uses its own frameptr X
  ldal _move_tail_UD_prm_tail_spr+1
  pha ; msb
  ldal _move_tail_UD_prm_tail_spr
  pha ; lsb
  lda _taily
  pha ; lsb
  lda _tailx
  pha ; lsb
  jsr ___spr_spriteplot8x8_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  lda _taily
  and #&07 ; lsb of 7
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x8_mode_5' uses its own frameptr X
  ldal _move_tail_UD_prm_body_spr
  clc
  adc #&04 ; lsb of 4
  tay
  ldal _move_tail_UD_prm_body_spr+1
  adc #&00 ; virtual msb of 2nd operand
  pha ; leave 16bit result on stack, msb first
  tya
  pha ; lsb
  lda _taily
  clc
  adcl _move_tail_UD_prm_offs1
  pha ; leave 8bit result on stack
  lda _tailx
  pha ; lsb
  jsr ___spr_spriteplot8x8_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
 .else_clause
.end_if: }
  lda #&00 ; lsb of 0
  sta _tailcornerstate
._exit_move_tail_UD
  rts
}
._end_of_move_tail_UD

._draw_tail_corner
{
  ; space for parameters: 3 byte(s)
  _draw_tail_corner_prm_corner_spr=&0103 ; 16bit function parameter 'corner_spr' of type 'word'
  _draw_tail_corner_prm_offs=&0105 ; 8bit function parameter 'offs' of type 'byte'
  tsx ; set new frame pointer X
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  ldal _draw_tail_corner_prm_corner_spr
  clc
  adcl _draw_tail_corner_prm_offs
  tay
  ldal _draw_tail_corner_prm_corner_spr+1
  adc #&00 ; virtual msb of 2nd operand
  pha ; leave 16bit result on stack, msb first
  tya
  pha ; lsb
  lda _tailcornery
  pha ; lsb
  lda _tailcornerx
  pha ; lsb
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
._exit_draw_tail_corner
  rts
}
._end_of_draw_tail_corner

._move_tail_corner_UD
{
  ; space for parameters: 10 byte(s)
  _move_tail_corner_UD_prm_ctype=&0103 ; 8bit function parameter 'ctype' of type 'byte'
  _move_tail_corner_UD_prm_offs1=&0104 ; 8bit function parameter 'offs1' of type 'int8'
  _move_tail_corner_UD_prm_offs2=&0105 ; 8bit function parameter 'offs2' of type 'int8'
  _move_tail_corner_UD_prm_offs3=&0106 ; 8bit function parameter 'offs3' of type 'int8'
  _move_tail_corner_UD_prm_offs4=&0107 ; 8bit function parameter 'offs4' of type 'int8'
  _move_tail_corner_UD_prm_offs5=&0108 ; 8bit function parameter 'offs5' of type 'int8'
  _move_tail_corner_UD_prm_tail_spr=&0109 ; 16bit function parameter 'tail_spr' of type 'word'
  _move_tail_corner_UD_prm_corner_spr=&010b ; 16bit function parameter 'corner_spr' of type 'word'
  tsx ; set new frame pointer X
  lda _tailcornerstate
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x8_mode_5' uses its own frameptr X
  ldal _move_tail_corner_UD_prm_tail_spr+1
  pha ; msb
  ldal _move_tail_corner_UD_prm_tail_spr
  pha ; lsb
  lda _taily
  pha ; lsb
  lda _tailx
  pha ; lsb
  jsr ___spr_spriteplot8x8_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  lda _tailx
  clc
  adcl _move_tail_corner_UD_prm_offs1
  sta _tailcornerx
  lda _taily
  clc
  adcl _move_tail_corner_UD_prm_offs2
  sta _tailcornery
  lda _tailcornerx
  clc
  adcl _move_tail_corner_UD_prm_offs3
  sta _tailx
  lda _tailcornery
  clc
  adcl _move_tail_corner_UD_prm_offs4
  sta _taily
  txa
  pha ; save current frameptr X, because function 'draw_tail_corner' uses its own frameptr X
  lda #&06 ; lsb of 6
  pha
  ldal _move_tail_corner_UD_prm_corner_spr+1
  pha ; msb
  ldal _move_tail_corner_UD_prm_corner_spr
  pha ; lsb
  jsr _draw_tail_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function '__spr_spriteplot8x8_mode_5' uses its own frameptr X
  ldal _move_tail_corner_UD_prm_tail_spr+1
  pha ; msb
  ldal _move_tail_corner_UD_prm_tail_spr
  pha ; lsb
  lda _tailcornery
  clc
  adcl _move_tail_corner_UD_prm_offs5
  pha ; leave 8bit result on stack
  lda _tailcornerx
  pha ; lsb
  jsr ___spr_spriteplot8x8_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_tail_corner' uses its own frameptr X
  lda #&08 ; lsb of 8
  pha
  ldal _move_tail_corner_UD_prm_corner_spr+1
  pha ; msb
  ldal _move_tail_corner_UD_prm_corner_spr
  pha ; lsb
  jsr _draw_tail_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  lda _tailcornerstate
  cmp #&02 ; lsb of 2
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x8_mode_5' uses its own frameptr X
  ldal _move_tail_corner_UD_prm_tail_spr+1
  pha ; msb
  ldal _move_tail_corner_UD_prm_tail_spr
  pha ; lsb
  lda _tailcornery
  clc
  adcl _move_tail_corner_UD_prm_offs5
  pha ; leave 8bit result on stack
  lda _tailcornerx
  pha ; lsb
  jsr ___spr_spriteplot8x8_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_tail_corner' uses its own frameptr X
  lda #&08 ; lsb of 8
  pha
  ldal _move_tail_corner_UD_prm_corner_spr+1
  pha ; msb
  ldal _move_tail_corner_UD_prm_corner_spr
  pha ; lsb
  jsr _draw_tail_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_tail_corner' uses its own frameptr X
  lda #&0a ; lsb of 10
  pha
  ldal _move_tail_corner_UD_prm_corner_spr+1
  pha ; msb
  ldal _move_tail_corner_UD_prm_corner_spr
  pha ; lsb
  jsr _draw_tail_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  lda _tailcornerstate
  cmp #&08 ; lsb of 8
  {: bcc if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'draw_tail_corner' uses its own frameptr X
  lda #&06 ; lsb of 6
  clc
  adc _tailcornerstate
  pha ; leave 8bit result on stack
  ldal _move_tail_corner_UD_prm_corner_spr+1
  pha ; msb
  ldal _move_tail_corner_UD_prm_corner_spr
  pha ; lsb
  jsr _draw_tail_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_tail_corner' uses its own frameptr X
  lda #&08 ; lsb of 8
  clc
  adc _tailcornerstate
  pha ; leave 8bit result on stack
  ldal _move_tail_corner_UD_prm_corner_spr+1
  pha ; msb
  ldal _move_tail_corner_UD_prm_corner_spr
  pha ; lsb
  jsr _draw_tail_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
 .else_clause
.end_if: }
.end_if: }
.end_if: }
  lda _tailcornerstate
  clc
  adc #&02 ; lsb of 2
  sta _tailcornerstate
._exit_move_tail_corner_UD
  rts
}
._end_of_move_tail_corner_UD

._move_tail_corner_LR
{
  ; space for parameters: 10 byte(s)
  _move_tail_corner_LR_prm_ctype=&0103 ; 8bit function parameter 'ctype' of type 'byte'
  _move_tail_corner_LR_prm_offs1=&0104 ; 8bit function parameter 'offs1' of type 'int8'
  _move_tail_corner_LR_prm_offs2=&0105 ; 8bit function parameter 'offs2' of type 'int8'
  _move_tail_corner_LR_prm_offs3=&0106 ; 8bit function parameter 'offs3' of type 'int8'
  _move_tail_corner_LR_prm_offs4=&0107 ; 8bit function parameter 'offs4' of type 'int8'
  _move_tail_corner_LR_prm_offs5=&0108 ; 8bit function parameter 'offs5' of type 'int8'
  _move_tail_corner_LR_prm_tail_spr=&0109 ; 16bit function parameter 'tail_spr' of type 'word'
  _move_tail_corner_LR_prm_corner_spr=&010b ; 16bit function parameter 'corner_spr' of type 'word'
  tsx ; set new frame pointer X
  lda _tailcornerstate
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  ldal _move_tail_corner_LR_prm_tail_spr+1
  pha ; msb
  ldal _move_tail_corner_LR_prm_tail_spr
  pha ; lsb
  lda _taily
  pha ; lsb
  lda _tailx
  pha ; lsb
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  lda _tailx
  clc
  adcl _move_tail_corner_LR_prm_offs1
  sta _tailcornerx
  lda _taily
  clc
  adcl _move_tail_corner_LR_prm_offs2
  sta _tailcornery
  lda _tailcornerx
  clc
  adcl _move_tail_corner_LR_prm_offs3
  sta _tailx
  lda _tailcornery
  clc
  adcl _move_tail_corner_LR_prm_offs4
  sta _taily
  txa
  pha ; save current frameptr X, because function 'draw_tail_corner' uses its own frameptr X
  lda #&06 ; lsb of 6
  pha
  ldal _move_tail_corner_LR_prm_corner_spr+1
  pha ; msb
  ldal _move_tail_corner_LR_prm_corner_spr
  pha ; lsb
  jsr _draw_tail_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  ldal _move_tail_corner_LR_prm_tail_spr+1
  pha ; msb
  ldal _move_tail_corner_LR_prm_tail_spr
  pha ; lsb
  lda _tailcornery
  pha ; lsb
  lda _tailcornerx
  clc
  adcl _move_tail_corner_LR_prm_offs5
  pha ; leave 8bit result on stack
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_tail_corner' uses its own frameptr X
  lda #&08 ; lsb of 8
  pha
  ldal _move_tail_corner_LR_prm_corner_spr+1
  pha ; msb
  ldal _move_tail_corner_LR_prm_corner_spr
  pha ; lsb
  jsr _draw_tail_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  lda _tailcornerstate
  cmp #&02 ; lsb of 2
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  ldal _move_tail_corner_LR_prm_tail_spr+1
  pha ; msb
  ldal _move_tail_corner_LR_prm_tail_spr
  pha ; lsb
  lda _tailcornery
  pha ; lsb
  lda _tailcornerx
  clc
  adcl _move_tail_corner_LR_prm_offs5
  pha ; leave 8bit result on stack
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_tail_corner' uses its own frameptr X
  lda #&08 ; lsb of 8
  pha
  ldal _move_tail_corner_LR_prm_corner_spr+1
  pha ; msb
  ldal _move_tail_corner_LR_prm_corner_spr
  pha ; lsb
  jsr _draw_tail_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_tail_corner' uses its own frameptr X
  lda #&0a ; lsb of 10
  pha
  ldal _move_tail_corner_LR_prm_corner_spr+1
  pha ; msb
  ldal _move_tail_corner_LR_prm_corner_spr
  pha ; lsb
  jsr _draw_tail_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  lda _tailcornerstate
  cmp #&08 ; lsb of 8
  {: bcc if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'draw_tail_corner' uses its own frameptr X
  lda #&06 ; lsb of 6
  clc
  adc _tailcornerstate
  pha ; leave 8bit result on stack
  ldal _move_tail_corner_LR_prm_corner_spr+1
  pha ; msb
  ldal _move_tail_corner_LR_prm_corner_spr
  pha ; lsb
  jsr _draw_tail_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'draw_tail_corner' uses its own frameptr X
  lda #&08 ; lsb of 8
  clc
  adc _tailcornerstate
  pha ; leave 8bit result on stack
  ldal _move_tail_corner_LR_prm_corner_spr+1
  pha ; msb
  ldal _move_tail_corner_LR_prm_corner_spr
  pha ; lsb
  jsr _draw_tail_corner
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
 .else_clause
.end_if: }
.end_if: }
.end_if: }
  lda _tailcornerstate
  clc
  adc #&02 ; lsb of 2
  sta _tailcornerstate
._exit_move_tail_corner_LR
  rts
}
._end_of_move_tail_corner_LR

._update_tail
{
  ; space for local variables: 2 byte(s)
  _update_tail_var_sync=&0100 ; 8bit local variable 'sync' of type 'int8'
  _update_tail_var_t=&00ff ; 8bit local variable 't' of type 'byte'
  tsx ; set new frame pointer X
  pha
  pha ; claim space (2 byte(s)) for local variables on stack
  stal _update_tail_var_sync ; ##inlineasm##
  lda _grow
  {: bne if_clause
  jmp else_clause: .if_clause
  dec _grow
  jmp _exit_update_tail
 .else_clause
.end_if: }
  lda #lo(python_trail)
  clc
  adc _tailtrail
  sta _e_t0
  lda #hi(python_trail)
  adc #&00 ; virtual msb of 2nd operand
  sta _e_t1
  ldy #&00
  lda (_e_t0),y ; get byte from address
  stal _update_tail_var_t
  inc _tailtrail
  ldal _update_tail_var_sync
  {: bne if_clause
  jmp else_clause: .if_clause
  jsr _sync_tail
 .else_clause
.end_if: }
  ldal _update_tail_var_t
  cmp #&82 ; lsb of 130
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'move_tail_LR' uses its own frameptr X
  lda #hi(tail_right_8x16x2_sprites)
  pha
  lda #lo(tail_right_8x16x2_sprites)
  pha
  lda #hi(body_right_4x16x3_sprites)
  pha
  lda #lo(body_right_4x16x3_sprites)
  pha
  lda #&04 ; lsb of 4
  pha
  lda #&02 ; lsb of 2
  pha
  lda #&82 ; lsb of 130
  pha
  jsr _move_tail_LR
  tsx
  txa
  clc
  adc #&07
  tax
  txs
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  ldal _update_tail_var_t
  cmp #&81 ; lsb of 129
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'move_tail_LR' uses its own frameptr X
  lda #hi(tail_left_8x16x2_sprites)
  pha
  lda #lo(tail_left_8x16x2_sprites)
  pha
  lda #hi(body_left_4x16x3_sprites)
  pha
  lda #lo(body_left_4x16x3_sprites)
  pha
  lda #&fc ; lsb of -4
  pha
  lda #&fe ; lsb of -2
  pha
  lda #&81 ; lsb of 129
  pha
  jsr _move_tail_LR
  tsx
  txa
  clc
  adc #&07
  tax
  txs
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  ldal _update_tail_var_t
  cmp #&83 ; lsb of 131
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'move_tail_UD' uses its own frameptr X
  lda #hi(tail_up_8x8x1_sprites)
  pha
  lda #lo(tail_up_8x8x1_sprites)
  pha
  lda #hi(body_up_8x8x3_sprites)
  pha
  lda #lo(body_up_8x8x3_sprites)
  pha
  lda #&f8 ; lsb of -8
  pha
  lda #&fc ; lsb of -4
  pha
  lda #&83 ; lsb of 131
  pha
  jsr _move_tail_UD
  tsx
  txa
  clc
  adc #&07
  tax
  txs
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  ldal _update_tail_var_t
  cmp #&84 ; lsb of 132
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'move_tail_UD' uses its own frameptr X
  lda #hi(tail_down_8x8x1_sprites)
  pha
  lda #lo(tail_down_8x8x1_sprites)
  pha
  lda #hi(body_down_8x8x3_sprites)
  pha
  lda #lo(body_down_8x8x3_sprites)
  pha
  lda #&08 ; lsb of 8
  pha
  lda #&04 ; lsb of 4
  pha
  lda #&84 ; lsb of 132
  pha
  jsr _move_tail_UD
  tsx
  txa
  clc
  adc #&07
  tax
  txs
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  ldal _update_tail_var_t
  cmp #&03 ; lsb of 3
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'move_tail_corner_LR' uses its own frameptr X
  lda #hi(corner_left_up_8x16x8_sprites)
  pha
  lda #lo(corner_left_up_8x16x8_sprites)
  pha
  lda #hi(tail_left_8x16x2_sprites)
  pha
  lda #lo(tail_left_8x16x2_sprites)
  pha
  lda #&06 ; lsb of 6
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&f8 ; lsb of -8
  pha
  lda #&03 ; lsb of 3
  pha
  jsr _move_tail_corner_LR
  tsx
  txa
  clc
  adc #&0a
  tax
  txs
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  ldal _update_tail_var_t
  cmp #&04 ; lsb of 4
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'move_tail_corner_LR' uses its own frameptr X
  lda #hi(corner_left_down_8x16x8_sprites)
  pha
  lda #lo(corner_left_down_8x16x8_sprites)
  pha
  lda #hi(tail_left_8x16x2_sprites)
  pha
  lda #lo(tail_left_8x16x2_sprites)
  pha
  lda #&06 ; lsb of 6
  pha
  lda #&08 ; lsb of 8
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&f8 ; lsb of -8
  pha
  lda #&04 ; lsb of 4
  pha
  jsr _move_tail_corner_LR
  tsx
  txa
  clc
  adc #&0a
  tax
  txs
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  ldal _update_tail_var_t
  cmp #&01 ; lsb of 1
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'move_tail_corner_LR' uses its own frameptr X
  lda #hi(corner_right_up_8x16x8_sprites)
  pha
  lda #lo(corner_right_up_8x16x8_sprites)
  pha
  lda #hi(tail_right_8x16x2_sprites)
  pha
  lda #lo(tail_right_8x16x2_sprites)
  pha
  lda #&fe ; lsb of -2
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&04 ; lsb of 4
  pha
  lda #&01 ; lsb of 1
  pha
  jsr _move_tail_corner_LR
  tsx
  txa
  clc
  adc #&0a
  tax
  txs
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  ldal _update_tail_var_t
  cmp #&02 ; lsb of 2
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'move_tail_corner_LR' uses its own frameptr X
  lda #hi(corner_right_down_8x16x8_sprites)
  pha
  lda #lo(corner_right_down_8x16x8_sprites)
  pha
  lda #hi(tail_right_8x16x2_sprites)
  pha
  lda #lo(tail_right_8x16x2_sprites)
  pha
  lda #&fe ; lsb of -2
  pha
  lda #&08 ; lsb of 8
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&04 ; lsb of 4
  pha
  lda #&02 ; lsb of 2
  pha
  jsr _move_tail_corner_LR
  tsx
  txa
  clc
  adc #&0a
  tax
  txs
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  ldal _update_tail_var_t
  cmp #&06 ; lsb of 6
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'move_tail_corner_UD' uses its own frameptr X
  lda #hi(corner_up_right_8x16x8_sprites)
  pha
  lda #lo(corner_up_right_8x16x8_sprites)
  pha
  lda #hi(tail_up_8x8x1_sprites)
  pha
  lda #lo(tail_up_8x8x1_sprites)
  pha
  lda #&0c ; lsb of 12
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&04 ; lsb of 4
  pha
  lda #&f0 ; lsb of -16
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&06 ; lsb of 6
  pha
  jsr _move_tail_corner_UD
  tsx
  txa
  clc
  adc #&0a
  tax
  txs
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  ldal _update_tail_var_t
  cmp #&05 ; lsb of 5
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'move_tail_corner_UD' uses its own frameptr X
  lda #hi(corner_up_left_8x16x8_sprites)
  pha
  lda #lo(corner_up_left_8x16x8_sprites)
  pha
  lda #hi(tail_up_8x8x1_sprites)
  pha
  lda #lo(tail_up_8x8x1_sprites)
  pha
  lda #&0c ; lsb of 12
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&f0 ; lsb of -16
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&05 ; lsb of 5
  pha
  jsr _move_tail_corner_UD
  tsx
  txa
  clc
  adc #&0a
  tax
  txs
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  ldal _update_tail_var_t
  cmp #&08 ; lsb of 8
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'move_tail_corner_UD' uses its own frameptr X
  lda #hi(corner_down_right_8x16x8_sprites)
  pha
  lda #lo(corner_down_right_8x16x8_sprites)
  pha
  lda #hi(tail_down_8x8x1_sprites)
  pha
  lda #lo(tail_down_8x8x1_sprites)
  pha
  lda #&fc ; lsb of -4
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&04 ; lsb of 4
  pha
  lda #&08 ; lsb of 8
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&08 ; lsb of 8
  pha
  jsr _move_tail_corner_UD
  tsx
  txa
  clc
  adc #&0a
  tax
  txs
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  ldal _update_tail_var_t
  cmp #&07 ; lsb of 7
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'move_tail_corner_UD' uses its own frameptr X
  lda #hi(corner_down_left_8x16x8_sprites)
  pha
  lda #lo(corner_down_left_8x16x8_sprites)
  pha
  lda #hi(tail_down_8x8x1_sprites)
  pha
  lda #lo(tail_down_8x8x1_sprites)
  pha
  lda #&fc ; lsb of -4
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&08 ; lsb of 8
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&07 ; lsb of 7
  pha
  jsr _move_tail_corner_UD
  tsx
  txa
  clc
  adc #&0a
  tax
  txs
  pla
  tax ; restore previous frameptr X
 .else_clause
.end_if: }
.end_if: }
.end_if: }
.end_if: }
.end_if: }
.end_if: }
.end_if: }
.end_if: }
.end_if: }
.end_if: }
.end_if: }
.end_if: }
._exit_update_tail
  txs ; release stack space (2 byte(s)) for local variables
  rts
}
._end_of_update_tail

._play_tune
{
  lda _tune_enabled
  {: bne if_clause
  jmp else_clause: .if_clause
  lda _tune_counter
  {: bne if_clause
  jmp else_clause: .if_clause
  dec _tune_counter
  jmp end_if: .else_clause
  lda _tune_counter_reload
  sta _tune_counter
  lda _tune_index
  sta _e_t0
  lda _tune_index+1
  sta _e_t1
  ldy #&00
  lda (_e_t0),y ; get byte from address
  sec
  sbc #&ff ; lsb of -1
  {: beq if_clause
  jmp else_clause: .if_clause
  lda #lo(tune_data)
  sta _tune_index ; lsb
  lda #hi(tune_data)
  sta _tune_index+1 ; msb
 .else_clause
.end_if: }
  lda _tune_index
  sta _e_t0
  lda _tune_index+1
  sta _e_t1
  ldy #&00
  lda (_e_t0),y ; get byte from address
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'qsound' uses its own frameptr X
  lda _tune_note_len
  pha ; lsb
  lda _tune_index
  sta _e_t0
  lda _tune_index+1
  sta _e_t1
  ldy #&00
  lda (_e_t0),y ; get byte from address
  pha ; leave on stack
  lda #&01 ; lsb of 1
  pha
  jsr _qsound
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
 .else_clause
.end_if: }
  inc _tune_index ; lsb
  {: bne skip_msb ; do lsb only, skip msb
  inc _tune_index+1: .skip_msb: } ; msb
.end_if: }
 .else_clause
.end_if: }
._exit_play_tune
  rts
}
._end_of_play_tune

._time_tick
{
  lda _time_enabled
  {: bne if_clause
  jmp else_clause: .if_clause
  lda _time_counter
  {: bne if_clause
  jmp else_clause: .if_clause
  dec _time_counter
  jmp end_if: .else_clause
  lda _time_counter_reload
  sta _time_counter
  dec _time
  lda #&01 ; lsb of 1
  sta _time_needs_update
.end_if: }
 .else_clause
.end_if: }
._exit_time_tick
  rts
}
._end_of_time_tick

._update_time
{
  lda #&00 ; lsb of 0
  sta _time_needs_update
  lda #&11 ; lsb of 17
  ldy #&01 ; lsb of 1

  jsr _cursorto
  lda _time
  sec
  sbc #&0a ; lsb of 10
  {: bmi if_clause
  jmp else_clause: .if_clause
  lda #&00 ; lsb of 0
  jsr _e_print_uint8
  lda #&00 ; lsb of 0
  jsr _e_print_uint8
  lda #&13 ; lsb of 19
  ldy #&01 ; lsb of 1

  jsr _cursorto
  jmp end_if: .else_clause
  lda _time
  sec
  sbc #&64 ; lsb of 100
  {: bmi if_clause
  jmp else_clause: .if_clause
  lda #&00 ; lsb of 0
  jsr _e_print_uint8
  lda #&12 ; lsb of 18
  ldy #&01 ; lsb of 1

  jsr _cursorto
 .else_clause
.end_if: }
.end_if: }
  lda _time
  jsr _e_print_int8
._exit_update_time
  rts
}
._end_of_update_time

._update_lives
{
  lda #&0c ; lsb of 12
  ldy #&01 ; lsb of 1

  jsr _cursorto
  lda _lives
  jsr _e_print_uint8
._exit_update_lives
  rts
}
._end_of_update_lives

._update_level
{
  lda #&07 ; lsb of 7
  ldy #&01 ; lsb of 1

  jsr _cursorto
  lda _level
  jsr _e_print_uint8
._exit_update_level
  rts
}
._end_of_update_level

._update_hiscore
{
  ; space for local variables: 1 byte(s)
  _update_hiscore_var_x=&0100 ; 8bit local variable 'x' of type 'byte'
  tsx ; set new frame pointer X
  pha ; claim space (1 byte(s)) for local variables on stack
  lda #&09 ; lsb of 9
  stal _update_hiscore_var_x
  lda _hiscore+1
  pha ; msb
  lda #&0a ; lsb of 10
  sta _e_t0
  lda _hiscore
  sta _e_t1
  ldy #&00: { ; assume false
  pla ; msb of op1
  bne false
  lda _e_t1 ; msb of op1 is 0, so compare lsb
  cmp _e_t0
  bcs false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  {: bne if_clause
  jmp else_clause: .if_clause
  lda #&0d ; lsb of 13
  stal _update_hiscore_var_x
  jmp end_if: .else_clause
  lda _hiscore+1
  pha ; msb
  lda #&64 ; lsb of 100
  sta _e_t0
  lda _hiscore
  sta _e_t1
  ldy #&00: { ; assume false
  pla ; msb of op1
  bne false
  lda _e_t1 ; msb of op1 is 0, so compare lsb
  cmp _e_t0
  bcs false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  {: bne if_clause
  jmp else_clause: .if_clause
  lda #&0c ; lsb of 12
  stal _update_hiscore_var_x
  jmp end_if: .else_clause
  lda _hiscore+1
  ldy #&00: { ; assume false
  cmp #&03 ; msb of 1000
  bcc true
  beq check_lsb
  bcs false: .check_lsb
  lda _hiscore
  cmp #&e8 ; lsb of 1000
  bcs false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  {: bne if_clause
  jmp else_clause: .if_clause
  lda #&0b ; lsb of 11
  stal _update_hiscore_var_x
  jmp end_if: .else_clause
  lda _hiscore+1
  ldy #&00: { ; assume false
  cmp #&27 ; msb of 10000
  bcc true
  beq check_lsb
  bcs false: .check_lsb
  lda _hiscore
  cmp #&10 ; lsb of 10000
  bcs false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  {: bne if_clause
  jmp else_clause: .if_clause
  lda #&0a ; lsb of 10
  stal _update_hiscore_var_x
 .else_clause
.end_if: }
.end_if: }
.end_if: }
.end_if: }
  ldal _update_hiscore_var_x
  ldy #&0b ; lsb of 11

  jsr _cursorto
  ldy _hiscore
  lda _hiscore+1
  jsr _e_print_uint16
._exit_update_hiscore
  txs ; release stack space (1 byte(s)) for local variables
  rts
}
._end_of_update_hiscore

._update_score
{
  ; space for local variables: 1 byte(s)
  _update_score_var_x=&0100 ; 8bit local variable 'x' of type 'byte'
  tsx ; set new frame pointer X
  pha ; claim space (1 byte(s)) for local variables on stack
  lda #&00 ; lsb of 0
  stal _update_score_var_x
  lda _score+1
  pha ; msb
  lda #&0a ; lsb of 10
  sta _e_t0
  lda _score
  sta _e_t1
  ldy #&00: { ; assume false
  pla ; msb of op1
  bne false
  lda _e_t1 ; msb of op1 is 0, so compare lsb
  cmp _e_t0
  bcs false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  {: bne if_clause
  jmp else_clause: .if_clause
  lda #&04 ; lsb of 4
  stal _update_score_var_x
  jmp end_if: .else_clause
  lda _score+1
  pha ; msb
  lda #&64 ; lsb of 100
  sta _e_t0
  lda _score
  sta _e_t1
  ldy #&00: { ; assume false
  pla ; msb of op1
  bne false
  lda _e_t1 ; msb of op1 is 0, so compare lsb
  cmp _e_t0
  bcs false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  {: bne if_clause
  jmp else_clause: .if_clause
  lda #&03 ; lsb of 3
  stal _update_score_var_x
  jmp end_if: .else_clause
  lda _score+1
  ldy #&00: { ; assume false
  cmp #&03 ; msb of 1000
  bcc true
  beq check_lsb
  bcs false: .check_lsb
  lda _score
  cmp #&e8 ; lsb of 1000
  bcs false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  {: bne if_clause
  jmp else_clause: .if_clause
  lda #&02 ; lsb of 2
  stal _update_score_var_x
  jmp end_if: .else_clause
  lda _score+1
  ldy #&00: { ; assume false
  cmp #&27 ; msb of 10000
  bcc true
  beq check_lsb
  bcs false: .check_lsb
  lda _score
  cmp #&10 ; lsb of 10000
  bcs false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  {: bne if_clause
  jmp else_clause: .if_clause
  lda #&01 ; lsb of 1
  stal _update_score_var_x
 .else_clause
.end_if: }
.end_if: }
.end_if: }
.end_if: }
  ldal _update_score_var_x
  ldy #&01 ; lsb of 1

  jsr _cursorto
  ldy _score
  lda _score+1
  jsr _e_print_uint16
._exit_update_score
  txs ; release stack space (1 byte(s)) for local variables
  rts
}
._end_of_update_score

._check_object
{
  ; space for local variables: 2 byte(s)
  _check_object_var_p=&0100 ; 8bit local variable 'p' of type 'byte'
  _check_object_var_dir=&00ff ; 8bit local variable 'dir' of type 'byte'
  tsx ; set new frame pointer X
  pha
  pha ; claim space (2 byte(s)) for local variables on stack
   ; ##inlineasm##
      stal _check_object_var_p ; ##inlineasm##
      tya ; ##inlineasm##
      stal _check_object_var_dir ; ##inlineasm##
   ; ##inlineasm##
  ldal _check_object_var_p
  cmp #&09 ; lsb of 9
  {: bcs if_clause
  jmp else_clause: .if_clause
  ldal _check_object_var_p
  and #&0f ; lsb of 15
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'qsound' uses its own frameptr X
  lda #&01 ; lsb of 1
  pha
  lda #&a0 ; lsb of 160
  pha
  lda #&02 ; lsb of 2
  pha
  jsr _qsound
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'qsound' uses its own frameptr X
  lda #&01 ; lsb of 1
  pha
  lda #&c8 ; lsb of 200
  pha
  lda #&02 ; lsb of 2
  pha
  jsr _qsound
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  lda _score
  clc
  adc #&05 ; lsb of 5
  sta _score ; lsb
  lda _score+1
  adc #&00 ; virtual msb of 2nd operand
  sta _score+1 ; msb
  dec _n_diamonds
  txa
  pha ; save current frameptr X, because function 'update_score' uses its own frameptr X
  jsr _update_score
  pla
  tax ; restore previous frameptr X
  lda _grow
  clc
  adc #&08 ; lsb of 8
  sta _grow
  ldal _check_object_var_dir
  cmp #&83 ; lsb of 131
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  lda #hi(diamond_8x16x1_sprites)
  pha
  lda #lo(diamond_8x16x1_sprites)
  pha
  lda _heady
  sec
  sbc #&10 ; lsb of 16
  pha ; leave 8bit result on stack
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  ldal _check_object_var_dir
  cmp #&84 ; lsb of 132
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  lda #hi(diamond_8x16x1_sprites)
  pha
  lda #lo(diamond_8x16x1_sprites)
  pha
  lda _heady
  clc
  adc #&10 ; lsb of 16
  pha ; leave 8bit result on stack
  lda _headx
  pha ; lsb
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  ldal _check_object_var_dir
  cmp #&81 ; lsb of 129
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  lda #hi(diamond_8x16x1_sprites)
  pha
  lda #lo(diamond_8x16x1_sprites)
  pha
  lda _heady
  pha ; lsb
  lda _headx
  sec
  sbc #&08 ; lsb of 8
  pha ; leave 8bit result on stack
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  lda #hi(diamond_8x16x1_sprites)
  pha
  lda #lo(diamond_8x16x1_sprites)
  pha
  lda _heady
  pha ; lsb
  lda _headx
  clc
  adc #&08 ; lsb of 8
  pha ; leave 8bit result on stack
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
.end_if: }
.end_if: }
.end_if: }
  jmp end_if: .else_clause
  lda #&01 ; lsb of 1
  sta _stuck
.end_if: }
  jmp end_if: .else_clause
  lda #&08 ; lsb of 8
  sta _time_counter_reload
.end_if: }
._exit_check_object
  txs ; release stack space (2 byte(s)) for local variables
  rts
}
._end_of_check_object

._check_up
{
  ; space for local variables: 1 byte(s)
  _check_up_var_p=&0100 ; 8bit local variable 'p' of type 'byte'
  tsx ; set new frame pointer X
  pha ; claim space (1 byte(s)) for local variables on stack
  pha ; reserve space for 8bit function result of function '__gfx_getpixel_mode_5'
  txa
  pha ; save current frameptr X, because function '__gfx_getpixel_mode_5' uses its own frameptr X
  lda _heady
  sec
  sbc #&03 ; lsb of 3
  pha ; leave 8bit result on stack
  lda _headx
  clc
  adc #&03 ; lsb of 3
  sta _e_t0 ; and remember
  pla
  tay ; get Y (2nd arg) from stack
  lda _e_t0 ; get A (1st arg)

  jsr ___gfx_getpixel_mode_5
  pla
  tax ; restore previous frameptr X
  pla
  stal _check_up_var_p
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'check_object' uses its own frameptr X
  ldal _check_up_var_p
  ldy #&83 ; lsb of 131

  jsr _check_object
  pla
  tax ; restore previous frameptr X
  pha ; reserve space for 8bit function result of function '__gfx_getpixel_mode_5'
  txa
  pha ; save current frameptr X, because function '__gfx_getpixel_mode_5' uses its own frameptr X
  lda _heady
  sec
  sbc #&03 ; lsb of 3
  pha ; leave 8bit result on stack
  lda _headx
  clc
  adc #&03 ; lsb of 3
  sta _e_t0 ; and remember
  pla
  tay ; get Y (2nd arg) from stack
  lda _e_t0 ; get A (1st arg)

  jsr ___gfx_getpixel_mode_5
  pla
  tax ; restore previous frameptr X
  pla
  stal _check_up_var_p
 .else_clause
.end_if: }
  ldal _check_up_var_p
  {: beq if_clause
  jmp else_clause: .if_clause
  lda #&32 ; lsb of 50
  sta _time_counter_reload
  lda _state
  cmp #&83 ; lsb of 131
  {: beq if_clause
  jmp else_clause: .if_clause
  jsr _python_up
  jmp end_if: .else_clause
  lda _state
  ldy #&00: { ; assume false
  cmp #&81 ; lsb of 129
  bne false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  pha ; push resulting boolean (0=false, -1=true)
  lda _state
  ldy #&00: { ; assume false
  cmp #&82 ; lsb of 130
  bne false: .true
  dey: .false: } ; Y=-1 (true)
  sty _e_t0
  pla ; 1st operand (8bit)
  ora _e_t0
  {: bne if_clause
  jmp else_clause: .if_clause
  lda _state
  cmp #&81 ; lsb of 129
  {: beq if_clause
  jmp else_clause: .if_clause
  lda #&03 ; lsb of 3
  sta _headcornertype
  jmp end_if: .else_clause
  lda #&01 ; lsb of 1
  sta _headcornertype
.end_if: }
  lda #&00 ; lsb of 0
  sta _headcornerstate
  lda _headx
  sta _headcornerx
  lda _heady
  sta _headcornery
  lda #&83 ; lsb of 131
  sta _state
  jsr _python_up
 .else_clause
.end_if: }
.end_if: }
 .else_clause
.end_if: }
._exit_check_up
  txs ; release stack space (1 byte(s)) for local variables
  rts
}
._end_of_check_up

._check_down
{
  ; space for local variables: 1 byte(s)
  _check_down_var_p=&0100 ; 8bit local variable 'p' of type 'byte'
  tsx ; set new frame pointer X
  pha ; claim space (1 byte(s)) for local variables on stack
  pha ; reserve space for 8bit function result of function '__gfx_getpixel_mode_5'
  txa
  pha ; save current frameptr X, because function '__gfx_getpixel_mode_5' uses its own frameptr X
  lda _heady
  clc
  adc #&12 ; lsb of 18
  pha ; leave 8bit result on stack
  lda _headx
  clc
  adc #&03 ; lsb of 3
  sta _e_t0 ; and remember
  pla
  tay ; get Y (2nd arg) from stack
  lda _e_t0 ; get A (1st arg)

  jsr ___gfx_getpixel_mode_5
  pla
  tax ; restore previous frameptr X
  pla
  stal _check_down_var_p
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'check_object' uses its own frameptr X
  ldal _check_down_var_p
  ldy #&84 ; lsb of 132

  jsr _check_object
  pla
  tax ; restore previous frameptr X
  pha ; reserve space for 8bit function result of function '__gfx_getpixel_mode_5'
  txa
  pha ; save current frameptr X, because function '__gfx_getpixel_mode_5' uses its own frameptr X
  lda _heady
  clc
  adc #&12 ; lsb of 18
  pha ; leave 8bit result on stack
  lda _headx
  clc
  adc #&03 ; lsb of 3
  sta _e_t0 ; and remember
  pla
  tay ; get Y (2nd arg) from stack
  lda _e_t0 ; get A (1st arg)

  jsr ___gfx_getpixel_mode_5
  pla
  tax ; restore previous frameptr X
  pla
  stal _check_down_var_p
 .else_clause
.end_if: }
  ldal _check_down_var_p
  {: beq if_clause
  jmp else_clause: .if_clause
  lda #&32 ; lsb of 50
  sta _time_counter_reload
  lda _state
  cmp #&84 ; lsb of 132
  {: beq if_clause
  jmp else_clause: .if_clause
  jsr _python_down
  jmp end_if: .else_clause
  lda _state
  ldy #&00: { ; assume false
  cmp #&81 ; lsb of 129
  bne false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  pha ; push resulting boolean (0=false, -1=true)
  lda _state
  ldy #&00: { ; assume false
  cmp #&82 ; lsb of 130
  bne false: .true
  dey: .false: } ; Y=-1 (true)
  sty _e_t0
  pla ; 1st operand (8bit)
  ora _e_t0
  {: bne if_clause
  jmp else_clause: .if_clause
  lda _state
  cmp #&81 ; lsb of 129
  {: beq if_clause
  jmp else_clause: .if_clause
  lda #&04 ; lsb of 4
  sta _headcornertype
  jmp end_if: .else_clause
  lda #&02 ; lsb of 2
  sta _headcornertype
.end_if: }
  lda #&00 ; lsb of 0
  sta _headcornerstate
  lda _headx
  sta _headcornerx
  lda _heady
  sta _headcornery
  lda #&84 ; lsb of 132
  sta _state
  jsr _python_down
 .else_clause
.end_if: }
.end_if: }
 .else_clause
.end_if: }
._exit_check_down
  txs ; release stack space (1 byte(s)) for local variables
  rts
}
._end_of_check_down

._check_left
{
  ; space for local variables: 1 byte(s)
  _check_left_var_p=&0100 ; 8bit local variable 'p' of type 'byte'
  tsx ; set new frame pointer X
  pha ; claim space (1 byte(s)) for local variables on stack
  pha ; reserve space for 8bit function result of function '__gfx_getpixel_mode_5'
  txa
  pha ; save current frameptr X, because function '__gfx_getpixel_mode_5' uses its own frameptr X
  lda _heady
  clc
  adc #&07 ; lsb of 7
  pha ; leave 8bit result on stack
  lda _headx
  sec
  sbc #&02 ; lsb of 2
  sta _e_t0 ; and remember
  pla
  tay ; get Y (2nd arg) from stack
  lda _e_t0 ; get A (1st arg)

  jsr ___gfx_getpixel_mode_5
  pla
  tax ; restore previous frameptr X
  pla
  stal _check_left_var_p
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'check_object' uses its own frameptr X
  ldal _check_left_var_p
  ldy #&81 ; lsb of 129

  jsr _check_object
  pla
  tax ; restore previous frameptr X
  pha ; reserve space for 8bit function result of function '__gfx_getpixel_mode_5'
  txa
  pha ; save current frameptr X, because function '__gfx_getpixel_mode_5' uses its own frameptr X
  lda _heady
  clc
  adc #&07 ; lsb of 7
  pha ; leave 8bit result on stack
  lda _headx
  sec
  sbc #&02 ; lsb of 2
  sta _e_t0 ; and remember
  pla
  tay ; get Y (2nd arg) from stack
  lda _e_t0 ; get A (1st arg)

  jsr ___gfx_getpixel_mode_5
  pla
  tax ; restore previous frameptr X
  pla
  stal _check_left_var_p
 .else_clause
.end_if: }
  ldal _check_left_var_p
  {: beq if_clause
  jmp else_clause: .if_clause
  lda #&32 ; lsb of 50
  sta _time_counter_reload
  lda _state
  cmp #&81 ; lsb of 129
  {: beq if_clause
  jmp else_clause: .if_clause
  jsr _python_left
  jmp end_if: .else_clause
  lda _state
  ldy #&00: { ; assume false
  cmp #&83 ; lsb of 131
  bne false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  pha ; push resulting boolean (0=false, -1=true)
  lda _state
  ldy #&00: { ; assume false
  cmp #&84 ; lsb of 132
  bne false: .true
  dey: .false: } ; Y=-1 (true)
  sty _e_t0
  pla ; 1st operand (8bit)
  ora _e_t0
  {: bne if_clause
  jmp else_clause: .if_clause
  lda _state
  cmp #&83 ; lsb of 131
  {: beq if_clause
  jmp else_clause: .if_clause
  lda #&05 ; lsb of 5
  sta _headcornertype
  jmp end_if: .else_clause
  lda #&07 ; lsb of 7
  sta _headcornertype
.end_if: }
  lda #&00 ; lsb of 0
  sta _headcornerstate
  lda _headx
  sta _headcornerx
  lda _heady
  sta _headcornery
  lda #&81 ; lsb of 129
  sta _state
  jsr _python_left
 .else_clause
.end_if: }
.end_if: }
 .else_clause
.end_if: }
._exit_check_left
  txs ; release stack space (1 byte(s)) for local variables
  rts
}
._end_of_check_left

._check_right
{
  ; space for local variables: 1 byte(s)
  _check_right_var_p=&0100 ; 8bit local variable 'p' of type 'byte'
  tsx ; set new frame pointer X
  pha ; claim space (1 byte(s)) for local variables on stack
  pha ; reserve space for 8bit function result of function '__gfx_getpixel_mode_5'
  txa
  pha ; save current frameptr X, because function '__gfx_getpixel_mode_5' uses its own frameptr X
  lda _heady
  clc
  adc #&07 ; lsb of 7
  pha ; leave 8bit result on stack
  lda _headx
  clc
  adc #&09 ; lsb of 9
  sta _e_t0 ; and remember
  pla
  tay ; get Y (2nd arg) from stack
  lda _e_t0 ; get A (1st arg)

  jsr ___gfx_getpixel_mode_5
  pla
  tax ; restore previous frameptr X
  pla
  stal _check_right_var_p
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'check_object' uses its own frameptr X
  ldal _check_right_var_p
  ldy #&82 ; lsb of 130

  jsr _check_object
  pla
  tax ; restore previous frameptr X
  pha ; reserve space for 8bit function result of function '__gfx_getpixel_mode_5'
  txa
  pha ; save current frameptr X, because function '__gfx_getpixel_mode_5' uses its own frameptr X
  lda _heady
  clc
  adc #&07 ; lsb of 7
  pha ; leave 8bit result on stack
  lda _headx
  clc
  adc #&09 ; lsb of 9
  sta _e_t0 ; and remember
  pla
  tay ; get Y (2nd arg) from stack
  lda _e_t0 ; get A (1st arg)

  jsr ___gfx_getpixel_mode_5
  pla
  tax ; restore previous frameptr X
  pla
  stal _check_right_var_p
 .else_clause
.end_if: }
  ldal _check_right_var_p
  {: beq if_clause
  jmp else_clause: .if_clause
  lda #&32 ; lsb of 50
  sta _time_counter_reload
  lda _state
  cmp #&82 ; lsb of 130
  {: beq if_clause
  jmp else_clause: .if_clause
  jsr _python_right
  jmp end_if: .else_clause
  lda _state
  ldy #&00: { ; assume false
  cmp #&83 ; lsb of 131
  bne false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  pha ; push resulting boolean (0=false, -1=true)
  lda _state
  ldy #&00: { ; assume false
  cmp #&84 ; lsb of 132
  bne false: .true
  dey: .false: } ; Y=-1 (true)
  sty _e_t0
  pla ; 1st operand (8bit)
  ora _e_t0
  {: bne if_clause
  jmp else_clause: .if_clause
  lda _state
  cmp #&83 ; lsb of 131
  {: beq if_clause
  jmp else_clause: .if_clause
  lda #&06 ; lsb of 6
  sta _headcornertype
  jmp end_if: .else_clause
  lda #&08 ; lsb of 8
  sta _headcornertype
.end_if: }
  lda #&00 ; lsb of 0
  sta _headcornerstate
  lda _headx
  sta _headcornerx
  lda _heady
  sta _headcornery
  lda #&82 ; lsb of 130
  sta _state
  jsr _python_right
 .else_clause
.end_if: }
.end_if: }
 .else_clause
.end_if: }
._exit_check_right
  txs ; release stack space (1 byte(s)) for local variables
  rts
}
._end_of_check_right

._aligned_to_grid
{
  _aligned_to_grid_result=&0104 ; 8bit function result of type 'int8'
  tsx ; set new frame pointer X
  lda _headx
  and #&07 ; lsb of 7
  {: bne if_clause
  jmp else_clause: .if_clause
  lda _state
  cmp #&82 ; lsb of 130
  {: beq if_clause
  jmp else_clause: .if_clause
  jsr _python_right
  jmp end_if: .else_clause
  jsr _python_left
.end_if: }
  lda #&00 ; lsb of 0
  stal _aligned_to_grid_result ; pop 8bit value and store in 8bit function result
  jmp _exit_aligned_to_grid
 .else_clause
.end_if: }
  lda _heady
  and #&0f ; lsb of 15
  {: bne if_clause
  jmp else_clause: .if_clause
  lda _state
  cmp #&84 ; lsb of 132
  {: beq if_clause
  jmp else_clause: .if_clause
  jsr _python_down
  jmp end_if: .else_clause
  jsr _python_up
.end_if: }
  lda #&00 ; lsb of 0
  stal _aligned_to_grid_result ; pop 8bit value and store in 8bit function result
  jmp _exit_aligned_to_grid
 .else_clause
.end_if: }
  lda #&01 ; lsb of 1
  stal _aligned_to_grid_result ; pop 8bit value and store in 8bit function result
._exit_aligned_to_grid
  rts
}
._end_of_aligned_to_grid

._tile_id
{
  _tile_id_result=&0104 ; 8bit function result of type 'int8'
  ; space for local variables: 2 byte(s)
  _tile_id_var_c=&0100 ; 8bit local variable 'c' of type 'byte'
  _tile_id_var_i=&00ff ; 8bit local variable 'i' of type 'int8'
  tsx ; set new frame pointer X
  pha
  pha ; claim space (2 byte(s)) for local variables on stack
  stal _tile_id_var_c ; ##inlineasm##
  lda #&0f ; lsb of 15
  stal _tile_id_var_i
{
.while_loop
  ldal _tile_id_var_i
  sec
  sbc #&00 ; lsb of 0
  bpl do_while
  jmp end_while: .do_while
  lda #hi(tiles)
  pha
  lda #lo(tiles)
  pha
  ldal _tile_id_var_i
  pha ; lsb
  ldy #&00 ; virtual msb of 2nd operand
  pla ; 2nd operand (8bit)
  sta _e_t0
  bpl *+3
  dey
  sty _e_t1
  pla ; 1st operand (lsb)
  clc
  adc _e_t0
  sta _e_t0
  pla ; 1st operand (msb)
  adc _e_t1
  sta _e_t1
  ldy #&00
  lda (_e_t0),y ; get byte from address
  cmpl _tile_id_var_c
  {: beq if_clause
  jmp else_clause: .if_clause
  ldal _tile_id_var_i
  asl a
  stal _tile_id_result ; pop 8bit value and store in 8bit function result
  jmp _exit_tile_id
 .else_clause
.end_if: }
  decl _tile_id_var_i
  jmp while_loop: .end_while: }
  lda #&ff ; lsb of -1
  stal _tile_id_result ; pop 8bit value and store in 8bit function result
._exit_tile_id
  txs ; release stack space (2 byte(s)) for local variables
  rts
}
._end_of_tile_id

._draw_level
{
  ; space for local variables: 7 byte(s)
  _draw_level_var_lvl=&0100 ; 8bit local variable 'lvl' of type 'byte'
  _draw_level_var_x=&00ff ; 8bit local variable 'x' of type 'byte'
  _draw_level_var_y=&00fe ; 8bit local variable 'y' of type 'byte'
  _draw_level_var_i=&00fd ; 8bit local variable 'i' of type 'int8'
  _draw_level_var_c=&00fc ; 8bit local variable 'c' of type 'byte'
  _draw_level_var_t=&00fa ; 16bit local variable 't' of type 'word'
  tsx ; set new frame pointer X
  pha
  pha
  pha
  pha
  pha
  pha
  pha ; claim space (7 byte(s)) for local variables on stack
  stal _draw_level_var_lvl ; ##inlineasm##
   ; ##inlineasm##
      ldal _draw_level_var_lvl ; ##inlineasm##
      asl a ; ##inlineasm##
      tay ; ##inlineasm##
      lda levels,y ; ##inlineasm##
      stal _draw_level_var_t ; ##inlineasm##
      lda levels+1,y ; ##inlineasm##
      stal _draw_level_var_t+1 ; ##inlineasm##
   ; ##inlineasm##
  lda #&01 ; lsb of 1
  ldy #&00 ; lsb of 0

  jsr _defcolour
  lda #&02 ; lsb of 2
  ldy #&00 ; lsb of 0

  jsr _defcolour
  lda #&03 ; lsb of 3
  ldy #&00 ; lsb of 0

  jsr _defcolour
  lda #&0c ; lsb of 12
  jsr _vdu
  ldal _draw_level_var_lvl
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'print_font_str_at' uses its own frameptr X
  lda #hi(str_score)
  pha
  lda #lo(str_score)
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&00 ; lsb of 0
  pha
  jsr _print_font_str_at
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'print_font_str_at' uses its own frameptr X
  lda #hi(str_00000)
  pha
  lda #lo(str_00000)
  pha
  lda #&08 ; lsb of 8
  pha
  lda #&00 ; lsb of 0
  pha
  jsr _print_font_str_at
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'update_score' uses its own frameptr X
  jsr _update_score
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'print_font_str_at' uses its own frameptr X
  lda #hi(str_time)
  pha
  lda #lo(str_time)
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&80 ; lsb of 128
  pha
  jsr _print_font_str_at
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jsr _update_time
  txa
  pha ; save current frameptr X, because function 'print_font_str_at' uses its own frameptr X
  lda #hi(str_level)
  pha
  lda #lo(str_level)
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&30 ; lsb of 48
  pha
  jsr _print_font_str_at
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jsr _update_level
  txa
  pha ; save current frameptr X, because function 'print_font_str_at' uses its own frameptr X
  lda #hi(str_lives)
  pha
  lda #lo(str_lives)
  pha
  lda #&00 ; lsb of 0
  pha
  lda #&50 ; lsb of 80
  pha
  jsr _print_font_str_at
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  jsr _update_lives
  jmp end_if: .else_clause
  txa
  pha ; save current frameptr X, because function 'print_font_str_at' uses its own frameptr X
  lda #hi(str_nameofgame)
  pha
  lda #lo(str_nameofgame)
  pha
  lda #&28 ; lsb of 40
  pha
  lda #&38 ; lsb of 56
  pha
  jsr _print_font_str_at
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'print_font_str_at' uses its own frameptr X
  lda #hi(str_left)
  pha
  lda #lo(str_left)
  pha
  lda #&78 ; lsb of 120
  pha
  lda #&30 ; lsb of 48
  pha
  jsr _print_font_str_at
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'print_font_str_at' uses its own frameptr X
  lda #hi(str_right)
  pha
  lda #lo(str_right)
  pha
  lda #&88 ; lsb of 136
  pha
  lda #&30 ; lsb of 48
  pha
  jsr _print_font_str_at
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'print_font_str_at' uses its own frameptr X
  lda #hi(str_up)
  pha
  lda #lo(str_up)
  pha
  lda #&98 ; lsb of 152
  pha
  lda #&30 ; lsb of 48
  pha
  jsr _print_font_str_at
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'print_font_str_at' uses its own frameptr X
  lda #hi(str_down)
  pha
  lda #lo(str_down)
  pha
  lda #&a8 ; lsb of 168
  pha
  lda #&30 ; lsb of 48
  pha
  jsr _print_font_str_at
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'print_font_str_at' uses its own frameptr X
  lda #hi(str_musiconoff)
  pha
  lda #lo(str_musiconoff)
  pha
  lda #&b8 ; lsb of 184
  pha
  lda #&30 ; lsb of 48
  pha
  jsr _print_font_str_at
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'print_font_str_at' uses its own frameptr X
  lda #hi(str_spacetoplay)
  pha
  lda #lo(str_spacetoplay)
  pha
  lda #&d0 ; lsb of 208
  pha
  lda #&20 ; lsb of 32
  pha
  jsr _print_font_str_at
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'print_font_str_at' uses its own frameptr X
  lda #hi(str_copyright)
  pha
  lda #lo(str_copyright)
  pha
  lda #&f4 ; lsb of 244
  pha
  lda #&14 ; lsb of 20
  pha
  jsr _print_font_str_at
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'print_font_str_at' uses its own frameptr X
  lda #hi(str_hiscore)
  pha
  lda #lo(str_hiscore)
  pha
  lda #&58 ; lsb of 88
  pha
  lda #&30 ; lsb of 48
  pha
  jsr _print_font_str_at
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'print_font_str_at' uses its own frameptr X
  lda #hi(str_00000)
  pha
  lda #lo(str_00000)
  pha
  lda #&58 ; lsb of 88
  pha
  lda #&48 ; lsb of 72
  pha
  jsr _print_font_str_at
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'update_hiscore' uses its own frameptr X
  jsr _update_hiscore
  pla
  tax ; restore previous frameptr X
.end_if: }
  lda #&10 ; lsb of 16
  stal _draw_level_var_y
{
.while_loop
  ldal _draw_level_var_y
  bne do_while
  jmp end_while: .do_while
  lda #&00 ; lsb of 0
  stal _draw_level_var_x
{
.while_loop
  ldal _draw_level_var_x
  cmp #&a0 ; lsb of 160
  bcc do_while
  jmp end_while: .do_while
  ldal _draw_level_var_t
  sta _e_t0
  ldal _draw_level_var_t+1
  sta _e_t1
  ldy #&00
  lda (_e_t0),y ; get byte from address
  stal _draw_level_var_c
  cmp #&2a ; lsb of 42
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  lda #hi(diamond_8x16x1_sprites)
  pha
  lda #lo(diamond_8x16x1_sprites)
  pha
  ldal _draw_level_var_y
  pha ; lsb
  ldal _draw_level_var_x
  pha ; lsb
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  inc _n_diamonds
  jmp end_if: .else_clause
  pha ; reserve space for 8bit function result of function 'tile_id'
  txa
  pha ; save current frameptr X, because function 'tile_id' uses its own frameptr X
  ldal _draw_level_var_c
  jsr _tile_id
  pla
  tax ; restore previous frameptr X
  pla
  stal _draw_level_var_i
  sec
  sbc #&00 ; lsb of 0
  {: bpl if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function '__spr_spriteplot8x16_mode_5' uses its own frameptr X
  lda #hi(tiles_8x16x16_sprites)
  pha
  lda #lo(tiles_8x16x16_sprites)
  pha
  ldal _draw_level_var_i
  pha ; lsb
  ldy #&00 ; virtual msb of 2nd operand
  pla ; 2nd operand (8bit)
  sta _e_t0
  bpl *+3
  dey
  sty _e_t1
  pla ; 1st operand (lsb)
  clc
  adc _e_t0
  tay
  pla ; 1st operand (msb)
  adc _e_t1
  pha ; leave 16bit result on stack, msb first
  tya
  pha ; lsb
  ldal _draw_level_var_y
  pha ; lsb
  ldal _draw_level_var_x
  pha ; lsb
  jsr ___spr_spriteplot8x16_mode_5
  pla
  pla
  pla
  pla ; free space on stack (4 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
 .else_clause
.end_if: }
.end_if: }
  incl _draw_level_var_t ; lsb
  bne *+5 ; do lsb only, skip msb
  incl _draw_level_var_t+1 ; msb
  ldal _draw_level_var_x
  clc
  adc #&08 ; lsb of 8
  stal _draw_level_var_x
  jmp while_loop: .end_while: }
  ldal _draw_level_var_y
  clc
  adc #&10 ; lsb of 16
  stal _draw_level_var_y
  jmp while_loop: .end_while: }
  ldal _draw_level_var_lvl
  and #&07 ; lsb of 7
  {: bne if_clause
  jmp else_clause: .if_clause
  ldal _draw_level_var_lvl
  and #&07 ; lsb of 7
  tay ; get Y (2nd arg) from stack
  lda #&01 ; lsb of 1
  sta _e_t0 ; and remember

  jsr _defcolour
  jmp end_if: .else_clause
  lda #&01 ; lsb of 1
  ldy #&01 ; lsb of 1

  jsr _defcolour
.end_if: }
  lda #&02 ; lsb of 2
  ldy #&02 ; lsb of 2

  jsr _defcolour
  lda #&03 ; lsb of 3
  ldy #&07 ; lsb of 7

  jsr _defcolour
._exit_draw_level
  txs ; release stack space (7 byte(s)) for local variables
  rts
}
._end_of_draw_level

._def_chars
{
  ; space for local variables: 4 byte(s)
  _def_chars_var_c=&0100 ; 8bit local variable 'c' of type 'byte'
  _def_chars_var_b=&00ff ; 8bit local variable 'b' of type 'byte'
  _def_chars_var_addr=&00fd ; 16bit local variable 'addr' of type 'word'
  tsx ; set new frame pointer X
  pha
  pha
  pha
  pha ; claim space (4 byte(s)) for local variables on stack
  lda #lo(digits_sprites)
  stal _def_chars_var_addr ; lsb
  lda #hi(digits_sprites)
  stal _def_chars_var_addr+1 ; msb
  lda #&30 ; lsb of 48
  stal _def_chars_var_c
{
.while_loop
  ldal _def_chars_var_c
  cmp #&3a ; lsb of 58
  bcc do_while
  jmp end_while: .do_while
  lda #&17 ; lsb of 23
  jsr _vdu
  ldal _def_chars_var_c
  jsr _vdu
  lda #&00 ; lsb of 0
  stal _def_chars_var_b
{
.while_loop
  ldal _def_chars_var_b
  cmp #&08 ; lsb of 8
  bcc do_while
  jmp end_while: .do_while
  ldal _def_chars_var_addr
  sta _e_t0
  ldal _def_chars_var_addr+1
  sta _e_t1
  ldy #&00
  lda (_e_t0),y ; get byte from address
  jsr _vdu
  incl _def_chars_var_addr ; lsb
  bne *+5 ; do lsb only, skip msb
  incl _def_chars_var_addr+1 ; msb
  incl _def_chars_var_b
  jmp while_loop: .end_while: }
  incl _def_chars_var_c
  jmp while_loop: .end_while: }
._exit_def_chars
  txs ; release stack space (4 byte(s)) for local variables
  rts
}
._end_of_def_chars

._get_ready
{
  ; space for local variables: 1 byte(s)
  _get_ready_var_n=&0100 ; 8bit local variable 'n' of type 'byte'
  tsx ; set new frame pointer X
  pha ; claim space (1 byte(s)) for local variables on stack
  lda #&15 ; lsb of 21
  stal _get_ready_var_n
{
.while_loop
  ldal _get_ready_var_n
  bne do_while
  jmp end_while: .do_while
  ldal _get_ready_var_n
  and #&01 ; lsb of 1
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'qsound' uses its own frameptr X
  lda #&01 ; lsb of 1
  pha
  lda #&78 ; lsb of 120
  pha
  lda #&02 ; lsb of 2
  pha
  jsr _qsound
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
 .else_clause
.end_if: }
  txa
  pha ; save current frameptr X, because function 'wait' uses its own frameptr X
  lda #&05 ; lsb of 5

  ldy #&00 ; convert 8bit (unsigned) argument to 16bit parameter '_cs', set msb=0 to extend unsigned 8bit to 16bit
  jsr _wait
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'init_and_draw_python' uses its own frameptr X
  lda #&0a ; lsb of 10
  pha
  lda #&e0 ; lsb of 224
  pha
  lda #&80 ; lsb of 128
  pha
  jsr _init_and_draw_python
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  decl _get_ready_var_n
  jmp while_loop: .end_while: }
._exit_get_ready
  txs ; release stack space (1 byte(s)) for local variables
  rts
}
._end_of_get_ready

._shrink_tail
{
  ; space for local variables: 1 byte(s)
  _shrink_tail_var_n=&0100 ; 8bit local variable 'n' of type 'byte'
  tsx ; set new frame pointer X
  pha ; claim space (1 byte(s)) for local variables on stack
  lda #&c8 ; lsb of 200
  stal _shrink_tail_var_n
  lda #&00 ; lsb of 0
  sta _grow
  sta _time_enabled
  sta _tune_enabled
  txa
  pha ; save current frameptr X, because function 'qsound' uses its own frameptr X
  lda #&0a ; lsb of 10
  pha
  lda #&05 ; lsb of 5
  pha
  lda #&00 ; lsb of 0
  pha
  jsr _qsound
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'wait' uses its own frameptr X
  lda #&1e ; lsb of 30

  ldy #&00 ; convert 8bit (unsigned) argument to 16bit parameter '_cs', set msb=0 to extend unsigned 8bit to 16bit
  jsr _wait
  pla
  tax ; restore previous frameptr X
{
.while_loop
  lda _tailtrail
  cmp _headtrail
  bne do_while
  jmp end_while: .do_while
  jsr _wait_vsync
  ldal _shrink_tail_var_n
  and #&01 ; lsb of 1
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'qsound' uses its own frameptr X
  lda #&01 ; lsb of 1
  pha
  ldal _shrink_tail_var_n
  pha ; lsb
  lda #&02 ; lsb of 2
  pha
  jsr _qsound
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
 .else_clause
.end_if: }
  txa
  pha ; save current frameptr X, because function 'update_tail' uses its own frameptr X
  lda #&00 ; lsb of 0
  jsr _update_tail
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'update_tail' uses its own frameptr X
  lda #&00 ; lsb of 0
  jsr _update_tail
  pla
  tax ; restore previous frameptr X
  decl _shrink_tail_var_n
  jmp while_loop: .end_while: }
._exit_shrink_tail
  txs ; release stack space (1 byte(s)) for local variables
  rts
}
._end_of_shrink_tail

._level_finished
{
  lda #&00 ; lsb of 0
  sta _grow
  sta _time_enabled
  sta _tune_enabled
  txa
  pha ; save current frameptr X, because function 'wait' uses its own frameptr X
  lda #&0a ; lsb of 10

  ldy #&00 ; convert 8bit (unsigned) argument to 16bit parameter '_cs', set msb=0 to extend unsigned 8bit to 16bit
  jsr _wait
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'qsound' uses its own frameptr X
  lda #&03 ; lsb of 3
  pha
  lda #&95 ; lsb of 149
  pha
  lda #&02 ; lsb of 2
  pha
  jsr _qsound
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'qsound' uses its own frameptr X
  lda #&03 ; lsb of 3
  pha
  lda #&a5 ; lsb of 165
  pha
  lda #&02 ; lsb of 2
  pha
  jsr _qsound
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'qsound' uses its own frameptr X
  lda #&06 ; lsb of 6
  pha
  lda #&c5 ; lsb of 197
  pha
  lda #&02 ; lsb of 2
  pha
  jsr _qsound
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'wait' uses its own frameptr X
  lda #&1e ; lsb of 30

  ldy #&00 ; convert 8bit (unsigned) argument to 16bit parameter '_cs', set msb=0 to extend unsigned 8bit to 16bit
  jsr _wait
  pla
  tax ; restore previous frameptr X
{
.while_loop
  lda _time
  sec
  sbc #&00 ; lsb of 0
  beq end
  bpl do_while: .end
  jmp end_while: .do_while
  dec _time
  lda _score
  clc
  adc #&0a ; lsb of 10
  sta _score ; lsb
  lda _score+1
  adc #&00 ; virtual msb of 2nd operand
  sta _score+1 ; msb
  jsr _wait_rtc
  jsr _wait_rtc
  jsr _update_time
  txa
  pha ; save current frameptr X, because function 'update_score' uses its own frameptr X
  jsr _update_score
  pla
  tax ; restore previous frameptr X
  lda _time
  and #&03 ; lsb of 3
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'qsound' uses its own frameptr X
  lda #&01 ; lsb of 1
  pha
  lda #&96 ; lsb of 150
  pha
  lda #&02 ; lsb of 2
  pha
  jsr _qsound
  pla
  pla
  pla ; free space on stack (3 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
 .else_clause
.end_if: }
  jmp while_loop: .end_while: }
._exit_level_finished
  rts
}
._end_of_level_finished

._game_loop
{
  ; space for local variables: 2 byte(s)
  _game_loop_var_p=&0100 ; 8bit local variable 'p' of type 'byte'
  _game_loop_var_q=&00ff ; 8bit local variable 'q' of type 'byte'
  tsx ; set new frame pointer X
  pha
  pha ; claim space (2 byte(s)) for local variables on stack
  lda #&00 ; lsb of 0
  sta _time_enabled
  sta _tune_enabled
  jsr _init
  lda #lo(_play_tune)
  ldy #hi(_play_tune)
  jsr _hook_vsync
  lda #lo(_time_tick)
  ldy #hi(_time_tick)
  jsr _hook_rtc
{
.while_loop
.do_while
  txa
  pha ; save current frameptr X, because function 'draw_level' uses its own frameptr X
  lda #&00 ; lsb of 0
  jsr _draw_level
  pla
  tax ; restore previous frameptr X
{
.while_loop
  pha ; reserve space for 8bit function result of function 'key'
  txa
  pha ; save current frameptr X, because function 'key' uses its own frameptr X
  lda #&9d ; lsb of -99
  jsr _key
  pla
  tax ; restore previous frameptr X
  pla ; 1st operand (8bit)
  beq do_while
  jmp end_while: .do_while
  jmp while_loop: .end_while: }
  jsr _init_game
{
.while_loop
  lda _lives
  cmp #&00 ; lsb of 0
  beq end
  bcs do_while: .end
  jmp end_while: .do_while
  jsr _init_level
  txa
  pha ; save current frameptr X, because function 'draw_level' uses its own frameptr X
  lda #&01 ; lsb of 1
  pha
  lda _level
  sec
  sbc #&01 ; lsb of 1
  and #&07 ; lsb of 7
  sta _e_t0
  pla ; 1st operand (8bit)
  clc
  adc _e_t0
  jsr _draw_level
  jsr _get_ready
  pla
  tax ; restore previous frameptr X
  lda #&82 ; lsb of 130
  sta _state
  lda #&01 ; lsb of 1
  sta _time_enabled
  lda _music_toggle
  sta _tune_enabled
{
.while_loop
  lda _time
  ldy #&00: { ; assume false
  sec
  sbc #&00 ; lsb of 0
  beq false
  bmi false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  pha ; push resulting boolean (0=false, -1=true)
  lda _stuck
  ldy #&00: { ; assume false
  sec
  sbc #&00 ; lsb of 0
  bne false: .true
  dey: .false: } ; Y=-1 (true)
  sty _e_t0
  pla ; 1st operand (8bit)
  and _e_t0
  pha ; leave 8bit result on stack
  lda _n_diamonds
  ldy #&00: { ; assume false
  cmp #&00 ; lsb of 0
  beq false
  bcc false: .true
  dey: .false: } ; Y=-1 (true)
  sty _e_t0
  pla ; 1st operand (8bit)
  and _e_t0
  bne do_while
  jmp end_while: .do_while
  lda _key_music_counter
  {: bne if_clause
  jmp else_clause: .if_clause
  dec _key_music_counter
  jmp end_if: .else_clause
  lda #&10 ; lsb of 16
  sta _key_music_counter
  pha ; reserve space for 8bit function result of function 'key'
  txa
  pha ; save current frameptr X, because function 'key' uses its own frameptr X
  lda #&9a ; lsb of -102
  jsr _key
  pla
  tax ; restore previous frameptr X
  pla
  {: bne if_clause
  jmp else_clause: .if_clause
  lda _music_toggle
  eor #&01 ; lsb of 1
  sta _music_toggle
  sta _tune_enabled
 .else_clause
.end_if: }
.end_if: }
  pha ; reserve space for 8bit function result of function 'aligned_to_grid'
  txa
  pha ; save current frameptr X, because function 'aligned_to_grid' uses its own frameptr X
  jsr _aligned_to_grid
  pla
  tax ; restore previous frameptr X
  pla
  {: bne if_clause
  jmp else_clause: .if_clause
  lda #&00 ; lsb of 0
  sta _moved
  pha ; reserve space for 8bit function result of function 'key'
  txa
  pha ; save current frameptr X, because function 'key' uses its own frameptr X
  lda #&9e ; lsb of -98
  jsr _key
  pla
  tax ; restore previous frameptr X
  lda _state
  ldy #&00: { ; assume false
  cmp #&82 ; lsb of 130
  beq false: .true
  dey: .false: } ; Y=-1 (true)
  sty _e_t0
  pla ; 1st operand (8bit)
  and _e_t0
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'check_left' uses its own frameptr X
  jsr _check_left
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  pha ; reserve space for 8bit function result of function 'key'
  txa
  pha ; save current frameptr X, because function 'key' uses its own frameptr X
  lda #&bd ; lsb of -67
  jsr _key
  pla
  tax ; restore previous frameptr X
  lda _state
  ldy #&00: { ; assume false
  cmp #&81 ; lsb of 129
  beq false: .true
  dey: .false: } ; Y=-1 (true)
  sty _e_t0
  pla ; 1st operand (8bit)
  and _e_t0
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'check_right' uses its own frameptr X
  jsr _check_right
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  pha ; reserve space for 8bit function result of function 'key'
  txa
  pha ; save current frameptr X, because function 'key' uses its own frameptr X
  lda #&b7 ; lsb of -73
  jsr _key
  pla
  tax ; restore previous frameptr X
  lda _state
  ldy #&00: { ; assume false
  cmp #&84 ; lsb of 132
  beq false: .true
  dey: .false: } ; Y=-1 (true)
  sty _e_t0
  pla ; 1st operand (8bit)
  and _e_t0
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'check_up' uses its own frameptr X
  jsr _check_up
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  pha ; reserve space for 8bit function result of function 'key'
  txa
  pha ; save current frameptr X, because function 'key' uses its own frameptr X
  lda #&97 ; lsb of -105
  jsr _key
  pla
  tax ; restore previous frameptr X
  lda _state
  ldy #&00: { ; assume false
  cmp #&83 ; lsb of 131
  beq false: .true
  dey: .false: } ; Y=-1 (true)
  sty _e_t0
  pla ; 1st operand (8bit)
  and _e_t0
  {: bne if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'check_down' uses its own frameptr X
  jsr _check_down
  pla
  tax ; restore previous frameptr X
 .else_clause
.end_if: }
.end_if: }
.end_if: }
.end_if: }
  lda _moved
  {: beq if_clause
  jmp else_clause: .if_clause
  lda _state
  cmp #&81 ; lsb of 129
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'check_left' uses its own frameptr X
  jsr _check_left
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  lda _state
  cmp #&82 ; lsb of 130
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'check_right' uses its own frameptr X
  jsr _check_right
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  lda _state
  cmp #&83 ; lsb of 131
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'check_up' uses its own frameptr X
  jsr _check_up
  pla
  tax ; restore previous frameptr X
  jmp end_if: .else_clause
  lda _state
  cmp #&84 ; lsb of 132
  {: beq if_clause
  jmp else_clause: .if_clause
  txa
  pha ; save current frameptr X, because function 'check_down' uses its own frameptr X
  jsr _check_down
  pla
  tax ; restore previous frameptr X
 .else_clause
.end_if: }
.end_if: }
.end_if: }
.end_if: }
 .else_clause
.end_if: }
 .else_clause
.end_if: }
  lda _time_needs_update
  {: bne if_clause
  jmp else_clause: .if_clause
  jsr _update_time
 .else_clause
.end_if: }
  lda _time
  sec
  sbc #&14 ; lsb of 20
  {: bmi if_clause
  jmp else_clause: .if_clause
  lda #&05 ; lsb of 5
  sta _tune_counter_reload
  lda #&02 ; lsb of 2
  sta _tune_note_len
  jmp end_if: .else_clause
  lda _time
  sec
  sbc #&32 ; lsb of 50
  {: bmi if_clause
  jmp else_clause: .if_clause
  lda #&08 ; lsb of 8
  sta _tune_counter_reload
  lda #&03 ; lsb of 3
  sta _tune_note_len
 .else_clause
.end_if: }
.end_if: }
  lda #&00 ; lsb of 0
  stal _game_loop_var_p
  pha ; reserve space for 8bit function result of function '__gfx_getpixel_mode_5'
  txa
  pha ; save current frameptr X, because function '__gfx_getpixel_mode_5' uses its own frameptr X
  lda _heady
  sec
  sbc #&03 ; lsb of 3
  tay ; get Y (2nd arg) from stack
  lda _headx
  sta _e_t0 ; and remember

  jsr ___gfx_getpixel_mode_5
  pla
  tax ; restore previous frameptr X
  pla
  stal _game_loop_var_q
  cmp #&09 ; lsb of 9
  {: bcc if_clause
  jmp else_clause: .if_clause
  ldal _game_loop_var_p
  oral _game_loop_var_q
  stal _game_loop_var_p
 .else_clause
.end_if: }
  pha ; reserve space for 8bit function result of function '__gfx_getpixel_mode_5'
  txa
  pha ; save current frameptr X, because function '__gfx_getpixel_mode_5' uses its own frameptr X
  lda _heady
  clc
  adc #&12 ; lsb of 18
  pha ; leave 8bit result on stack
  lda _headx
  clc
  adc #&03 ; lsb of 3
  sta _e_t0 ; and remember
  pla
  tay ; get Y (2nd arg) from stack
  lda _e_t0 ; get A (1st arg)

  jsr ___gfx_getpixel_mode_5
  pla
  tax ; restore previous frameptr X
  pla
  stal _game_loop_var_q
  cmp #&09 ; lsb of 9
  {: bcc if_clause
  jmp else_clause: .if_clause
  ldal _game_loop_var_p
  oral _game_loop_var_q
  stal _game_loop_var_p
 .else_clause
.end_if: }
  pha ; reserve space for 8bit function result of function '__gfx_getpixel_mode_5'
  txa
  pha ; save current frameptr X, because function '__gfx_getpixel_mode_5' uses its own frameptr X
  lda _heady
  clc
  adc #&07 ; lsb of 7
  pha ; leave 8bit result on stack
  lda _headx
  sec
  sbc #&02 ; lsb of 2
  sta _e_t0 ; and remember
  pla
  tay ; get Y (2nd arg) from stack
  lda _e_t0 ; get A (1st arg)

  jsr ___gfx_getpixel_mode_5
  pla
  tax ; restore previous frameptr X
  pla
  stal _game_loop_var_q
  cmp #&09 ; lsb of 9
  {: bcc if_clause
  jmp else_clause: .if_clause
  ldal _game_loop_var_p
  oral _game_loop_var_q
  stal _game_loop_var_p
 .else_clause
.end_if: }
  pha ; reserve space for 8bit function result of function '__gfx_getpixel_mode_5'
  txa
  pha ; save current frameptr X, because function '__gfx_getpixel_mode_5' uses its own frameptr X
  lda _heady
  clc
  adc #&07 ; lsb of 7
  pha ; leave 8bit result on stack
  lda _headx
  clc
  adc #&09 ; lsb of 9
  sta _e_t0 ; and remember
  pla
  tay ; get Y (2nd arg) from stack
  lda _e_t0 ; get A (1st arg)

  jsr ___gfx_getpixel_mode_5
  pla
  tax ; restore previous frameptr X
  pla
  stal _game_loop_var_q
  cmp #&09 ; lsb of 9
  {: bcc if_clause
  jmp else_clause: .if_clause
  ldal _game_loop_var_p
  oral _game_loop_var_q
  stal _game_loop_var_p
 .else_clause
.end_if: }
  ldal _game_loop_var_p
  ldy #&00: { ; assume false
  cmp #&07 ; lsb of 7
  bne false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  pha ; push resulting boolean (0=false, -1=true)
  ldal _game_loop_var_p
  ldy #&00: { ; assume false
  cmp #&0b ; lsb of 11
  bne false: .true
  dey: .false: } ; Y=-1 (true)
  sty _e_t0
  pla ; 1st operand (8bit)
  ora _e_t0
  pha ; leave 8bit result on stack
  ldal _game_loop_var_p
  ldy #&00: { ; assume false
  cmp #&0d ; lsb of 13
  bne false: .true
  dey: .false: } ; Y=-1 (true)
  sty _e_t0
  pla ; 1st operand (8bit)
  ora _e_t0
  pha ; leave 8bit result on stack
  ldal _game_loop_var_p
  ldy #&00: { ; assume false
  cmp #&0e ; lsb of 14
  bne false: .true
  dey: .false: } ; Y=-1 (true)
  sty _e_t0
  pla ; 1st operand (8bit)
  ora _e_t0
  {: bne if_clause
  jmp else_clause: .if_clause
  lda #&01 ; lsb of 1
  sta _stuck
 .else_clause
.end_if: }
  jmp while_loop: .end_while: }
  lda _n_diamonds
  {: beq if_clause
  jmp else_clause: .if_clause
  jsr _level_finished
  lda _level
  and #&07 ; lsb of 7
  {: beq if_clause
  jmp else_clause: .if_clause
  inc _lives
  lda _score
  clc
  adc #&e8 ; lsb of 1000
  sta _score ; lsb
  lda _score+1
  adc #&03 ; msb of 1000
  sta _score+1 ; msb
  lda _start_time
  sec
  sbc #&0a ; lsb of 10
  sta _start_time
 .else_clause
.end_if: }
  inc _level
  jmp end_if: .else_clause
  dec _lives
  txa
  pha ; save current frameptr X, because function 'shrink_tail' uses its own frameptr X
  jsr _shrink_tail
  pla
  tax ; restore previous frameptr X
.end_if: }
  jmp while_loop: .end_while: }
  lda _score+1
  ldy #&00: { ; assume false
  cmp _hiscore+1
  bcc false
  beq check_lsb
  bcs true: .check_lsb
  lda _score
  cmp _hiscore
  beq false
  bcc false: .true
  dey: .false: } ; Y=-1 (true)
  tya
  {: bne if_clause
  jmp else_clause: .if_clause
  lda _score
  sta _hiscore ; lsb
  lda _score+1
  sta _hiscore+1 ; msb
 .else_clause
.end_if: }
  jmp while_loop: .end_while: }
._exit_game_loop
  txs ; release stack space (2 byte(s)) for local variables
  rts
}
._end_of_game_loop

._main
{
   ; ##inlineasm##
      print "#### Free bytes:", &5800-* ; ##inlineasm##
      if (*>&5800): error "Compiled binary too large!": endif ; ##inlineasm##
   ; ##inlineasm##
  txa
  pha ; save current frameptr X, because function 'reloc_down' uses its own frameptr X
  lda #&02 ; msb of 512
  pha
  lda #&00 ; lsb of 512
  pha
  lda #hi(tiles_8x16x16)
  pha
  lda #lo(tiles_8x16x16)
  pha
  lda #&04 ; msb of 1024
  pha
  lda #&00 ; lsb of 1024
  pha
  jsr _reloc_down
  pla
  pla
  pla
  pla
  pla
  pla ; free space on stack (6 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'reloc_down' uses its own frameptr X
  lda #&02 ; msb of 512
  pha
  lda #&00 ; lsb of 512
  pha
  lda #hi(corner_up_left_8x16x8)
  pha
  lda #lo(corner_up_left_8x16x8)
  pha
  lda #&06 ; msb of 1536
  pha
  lda #&00 ; lsb of 1536
  pha
  jsr _reloc_down
  pla
  pla
  pla
  pla
  pla
  pla ; free space on stack (6 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'reloc_down' uses its own frameptr X
  lda #&02 ; msb of 512
  pha
  lda #&00 ; lsb of 512
  pha
  lda #hi(corner_down_left_8x16x8)
  pha
  lda #lo(corner_down_left_8x16x8)
  pha
  lda #&0a ; msb of 2560
  pha
  lda #&00 ; lsb of 2560
  pha
  jsr _reloc_down
  pla
  pla
  pla
  pla
  pla
  pla ; free space on stack (6 byte(s)) used for function parameters
  pla
  tax ; restore previous frameptr X
  pha ; save current frameptr X, because function 'game_loop' uses its own frameptr X
  jsr _game_loop
  pla
  tax ; restore previous frameptr X
  jmp _exit_main
   ; ##inlineasm##
    { ; ##inlineasm##
    .*tiles_8x16x16 ; ##inlineasm##
      incbin "gfx/tiles_8x16x16.bin" ; 512 bytes moved down to &400!! ; ##inlineasm##
   ; ##inlineasm##
    .*corner_up_left_8x16x8 ; ##inlineasm##
      incbin "gfx/corner_up_left_8x16x8.bin" ; 256 bytes moved down to &600!! ; ##inlineasm##
   ; ##inlineasm##
    .*corner_up_right_8x16x8 ; ##inlineasm##
      incbin "gfx/corner_up_right_8x16x8.bin" ; 256 bytes moved down to &700!! ; ##inlineasm##
   ; ##inlineasm##
    .*corner_down_left_8x16x8 ; ##inlineasm##
      incbin "gfx/corner_down_left_8x16x8.bin" ; 256 bytes moved down to &A00!! ; ##inlineasm##
   ; ##inlineasm##
    .*corner_down_right_8x16x8 ; ##inlineasm##
      incbin "gfx/corner_down_right_8x16x8.bin" ; 256 bytes moved down to &B00!! ; ##inlineasm##
    } ; ##inlineasm##
   ; ##inlineasm##
._exit_main
  rts
}
._end_of_main

._reloc_down
{
  ; space for parameters: 6 byte(s)
  _reloc_down_prm_dst=&0103 ; 16bit function parameter 'dst' of type 'word'
  _reloc_down_prm_src=&0105 ; 16bit function parameter 'src' of type 'word'
  _reloc_down_prm_len=&0107 ; 16bit function parameter 'len' of type 'int'
  tsx ; set new frame pointer X
{
.while_loop
  ldal _reloc_down_prm_len+1
  oral _reloc_down_prm_len
  bne do_while
  jmp end_while: .do_while
{
  ldal _reloc_down_prm_src
  sta _e_t0
  ldal _reloc_down_prm_src+1
  sta _e_t1
  ldy #&00
  lda (_e_t0),y ; get byte from address
  pha ; leave on stack
  ldal _reloc_down_prm_dst
  sta _e_t0
  ldal _reloc_down_prm_dst+1
  sta _e_t1
  ldy #&00
  pla ; get lsb of value
  sta (_e_t0),y ; and store it
}
  incl _reloc_down_prm_dst ; lsb
  bne *+5 ; do lsb only, skip msb
  incl _reloc_down_prm_dst+1 ; msb
  incl _reloc_down_prm_src ; lsb
  bne *+5 ; do lsb only, skip msb
  incl _reloc_down_prm_src+1 ; msb
  ldal _reloc_down_prm_len ; lsb
  bne *+5 ; do lsb only, skip msb
  decl _reloc_down_prm_len+1 ; msb
  decl _reloc_down_prm_len ; lsb
  jmp while_loop: .end_while: }
._exit_reloc_down
  rts
}
._end_of_reloc_down

.___program_end___

  puttext "!BOOT.txt", "!BOOT", 0, 0

  save ___program_start___, ___program_end___, ___program_start___, &0e00

























